<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="永远迎着光走">
<meta property="og:type" content="website">
<meta property="og:title" content="stars">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="stars">
<meta property="og:description" content="永远迎着光走">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="stars zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>stars</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">stars</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/19/Reactor%E5%92%8CProactor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stars zhang">
      <meta itemprop="description" content="永远迎着光走">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/19/Reactor%E5%92%8CProactor/" class="post-title-link" itemprop="url">Reactor和Proactor</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-19 19:30:26 / 修改时间：20:11:10" itemprop="dateCreated datePublished" datetime="2024-04-19T19:30:26+08:00">2024-04-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">网络编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Reactor模式和Proactor模式是两种常见的事件处理模式，通常用于构建高性能的并发系统。它们都是在事件驱动的系统中使用的设计模式，但它们在处理事件时的方式有所不同。下面我将详细解释它们的工作原理和区别。</p>
<h3 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h3><h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h4><p>在Reactor模式中，有一个事件循环（Event Loop），负责监听并分发事件。该循环通过轮询或者异步IO等机制监视多个输入源（如文件描述符、套接字等），当有事件发生时，调用相关的事件处理器来处理这些事件。在Reactor模式中，事件处理是同步的，即当一个事件发生时，Reactor会调用相应的事件处理器，并且一直等待处理器完成处理，然后再继续监听新的事件。</p>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><p>Reactor模式的主要特点包括：</p>
<ol>
<li>单线程：通常Reactor模式在单线程中运行，事件循环会按顺序处理事件。</li>
<li>同步处理：事件处理是同步的，一个事件处理器处理完事件之后，才会继续处理下一个事件。</li>
<li>高效：由于采用了非阻塞IO和事件驱动的方式，Reactor模式在高并发场景下表现出色。</li>
</ol>
<h4 id="单、多Reactor模式："><a href="#单、多Reactor模式：" class="headerlink" title="单、多Reactor模式："></a>单、多Reactor模式：</h4><p>在<strong>单Reactor模式</strong>中，只有一个事件循环负责监听和分发事件，并且事件处理是同步的，即事件处理器会在事件循环中同步执行。这种模式通常适用于轻量级的应用或者处理较少并发连接的情况。</p>
<p>与单Reactor模式不同，<strong>多Reactor模式</strong>通过将事件处理分布到多个事件循环中来提高系统的并发能力。每个事件循环负责监听和处理一部分事件，从而降低了单个事件循环的负载，提高了系统的并发处理能力。通常采用<strong>主从Reactor模式</strong>：</p>
<p>​	在主从Reactor模式中，通常有一个主Reactor负责监听连接请求，并且负责创建和分配子Reactor。当主Reactor接收到连接请求时，会将连接分配给某个子Reactor，然后由子Reactor负责处理该连接的事件。这样可以避免单个Reactor负载过重，并且能够充分利用多核处理器的性能。</p>
<h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>在Reactor模式中，回调函数被广泛应用于处理事件。回调函数是一种在某个事件发生时被调用的函数，用于处理特定类型的事件。在Reactor模式中，当事件发生时，事件循环会调用相应的回调函数来处理事件，例如读取数据、写入数据、关闭连接等。</p>
<p>具体来说，在多Reactor模式中，每个事件循环都会注册一组回调函数，用于处理不同类型的事件。当事件发生时，事件循环会根据事件的类型找到对应的回调函数，并调用它来处理事件。这样可以实现事件驱动的编程模型，将事件的处理与业务逻辑分离开来，提高了代码的可维护性和可扩展性。</p>
<p>举个例子，假设一个Web服务器使用多Reactor模式来处理客户端连接。每个事件循环会注册一组回调函数，包括处理新连接事件、读取数据事件、写入数据事件等。当有新的客户端连接到达时，主Reactor会接收到连接请求，并将连接分配给某个子Reactor。子Reactor会调用相应的回调函数来处理该连接的读取数据事件和写入数据事件。</p>
<h3 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h3><p>Proactor模式与Reactor模式有所不同。在Proactor模式中，操作（通常是IO操作）被提交给一个专门的组件，称为Proactor，然后由Proactor负责执行这些操作。当操作完成时，Proactor会通知相关的事件处理器，告诉它们操作已完成，可以进行下一步处理。与Reactor模式不同，Proactor模式中的事件处理是异步的，事件处理器不需要等待操作完成，而是在操作完成后得到通知。</p>
<p>Proactor模式的主要特点包括：</p>
<ol>
<li>异步处理：事件处理是异步的，事件处理器可以继续执行其他任务，而不必等待操作完成。</li>
<li>多线程：通常Proactor模式会使用多线程来处理IO操作，以提高系统的并发能力。</li>
<li>高性能：通过异步IO和多线程的结合，Proactor模式可以实现高性能的并发处理。</li>
</ol>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol>
<li><strong>同步 vs. 异步</strong>：Reactor模式中事件处理是同步的，而Proactor模式中事件处理是异步的。</li>
<li><strong>单线程 vs. 多线程</strong>：Reactor模式通常在单线程中运行，而Proactor模式通常使用多线程来处理IO操作。</li>
<li><strong>处理方式</strong>：在Reactor模式中，事件发生后Reactor负责调用事件处理器，而在Proactor模式中，操作完成后Proactor负责通知事件处理器。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/19/static%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stars zhang">
      <meta itemprop="description" content="永远迎着光走">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/19/static%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">static详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-19 16:55:53 / 修改时间：17:46:18" itemprop="dateCreated datePublished" datetime="2024-04-19T16:55:53+08:00">2024-04-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>static</code> 是 C++ 中的关键字，用于声明静态成员变量和静态成员函数，以及在局部变量中具有持久性。</p>
<h5 id="1-静态变量"><a href="#1-静态变量" class="headerlink" title="1. 静态变量"></a>1. 静态变量</h5><ol>
<li><p><strong>静态局部变量</strong>：在函数内部声明的静态变量。</p>
<p>在函数内部声明的静态变量，其生命周期<strong>跨越函数调用</strong>。它们<strong>只会在第一次函数调用时初始化</strong>，并且保留其值直到程序结束。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(); <span class="comment">// 输出：Count: 1</span></span><br><span class="line">    <span class="built_in">foo</span>(); <span class="comment">// 输出：Count: 2</span></span><br><span class="line">    <span class="built_in">foo</span>(); <span class="comment">// 输出：Count: 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>静态成员变量</strong>：静态成员变量<strong>属于类，而不是类的实例</strong>。它们<strong>被所有类的对象所共享</strong>，并且在类的所有实例中只有一个副本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::count = <span class="number">0</span>; <span class="comment">// 静态成员变量在类外部进行初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj1;</span><br><span class="line">    MyClass::count = <span class="number">5</span>; <span class="comment">// 通过类名访问静态成员变量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; obj1.count &lt;&lt; std::endl; <span class="comment">// 输出：Count: 5，因为静态成员变量是共享的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>静态全局变量</strong>：在函数外部声明的静态变量称为静态全局变量。它们的<strong>作用域限制在声明它们的文件内</strong>，并且在程序的整个生命周期内保留其值。</p>
<p>说到这，顺便说说<code>extern</code>关键字。它用于<strong>声明一个变量或函数是在其他文件中定义的，而不是在当前文件中定义的</strong>。即在当前文件中声明在其他文件中定义的变量或函数，以便在当前文件中使用它们。</p>
</li>
</ol>
<h5 id="2-静态函数"><a href="#2-静态函数" class="headerlink" title="2. 静态函数"></a>2. 静态函数</h5><p>静态成员函数：静态函数<strong>属于类，而不是类的实例</strong>。它们可以直接通过类名调用，而无需创建类的实例。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Math</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = Math::<span class="built_in">add</span>(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 直接通过类名调用静态函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; sum &lt;&lt; std::endl; <span class="comment">// 输出：Sum: 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/19/const%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stars zhang">
      <meta itemprop="description" content="永远迎着光走">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/19/const%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">const详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-19 15:34:46 / 修改时间：16:52:56" itemprop="dateCreated datePublished" datetime="2024-04-19T15:34:46+08:00">2024-04-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="const"><a href="#const" class="headerlink" title="const"></a>const</h5><p><code>const</code> 用于定义常量、声明常量引用以及修饰成员函数。<code>const</code> 的作用是告诉编译器这个东西是不可修改的，即它的值在初始化后不能再被修改。</p>
<p>编译器通常不为普通的const常量分配内存空间，而是将他们保存在符号表中。</p>
<h6 id="1-定义常量"><a href="#1-定义常量" class="headerlink" title="1. 定义常量"></a>1. 定义常量</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>定义了一个常量 <code>x</code>，其值为 5。一旦定义，就不能再修改 <code>x</code> 的值。</p>
<h6 id="2-const和引用"><a href="#2-const和引用" class="headerlink" title="2. const和引用"></a>2. const和引用</h6><p>把<code>const</code>修饰的引用称为”常用引用“，常量引用不能直接修改所引用的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">1024</span>;<span class="comment">//ci是一个int型的常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = ci;<span class="comment">//正确，r1是一个常量引用，并且r1本身也是一个常量</span></span><br><span class="line">r1 = <span class="number">42</span>;<span class="comment">//错误，引用被const限制了，不能修改所引用对象的值了</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = ci;<span class="comment">//错误，试图让一个非常量引用指向一个常量对象</span></span><br></pre></td></tr></table></figure>

<h6 id="3-const和指针"><a href="#3-const和指针" class="headerlink" title="3. const和指针"></a>3. const和指针</h6><ol>
<li><p>常量指针：指针指向的对象不可变，但指针本身的值可以改变。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr = &amp;x; <span class="comment">// ptr 是一个指向整型常量的指针，它所指向的对象不能被修改，但可以改变指针的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// *ptr = 10; // 错误，不能修改 ptr 所指向的对象的值</span></span><br><span class="line"><span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line">ptr = &amp;y; <span class="comment">// 可以修改指针 ptr 的值，使其指向不同的对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指针常量：指针本身的值不可变，但指针所指向的对象可以改变。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> ptr = &amp;x; <span class="comment">// ptr 是一个指向整型的常量指针，它的值不能改变，但可以修改其指向的对象</span></span><br><span class="line"></span><br><span class="line">*ptr = <span class="number">10</span>; <span class="comment">// 可以修改 ptr 所指向的对象的值</span></span><br><span class="line"><span class="comment">// ptr = &amp;y; // 错误，无法修改指针 ptr 的值</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h6 id="4-const和类对象"><a href="#4-const和类对象" class="headerlink" title="4. const和类对象"></a>4. const和类对象</h6><ol>
<li><p>const成员变量：</p>
<p>const 成员变量是指在类中声明为常量的数据成员。一旦被初始化，其值就不能再修改。它们只能在类的构造函数初始化列表中初始化，而不能在构造函数体中赋值。</p>
</li>
<li><p>const成员函数：</p>
<p>const只能限定类的成员函数，表示该函数不会修改类的成员变量，<strong>除非成员变量被 mutable 修饰符修饰</strong>。</p>
</li>
</ol>
<p>const限定后，该成员函数不允许修改类的数据成员，也不允许调用非const函数，即使该函数没有修改类的数据成员，只要没有声明成const，就不能调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数初始化 const 成员变量</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x): <span class="built_in">constValue</span>(x) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这是一个常量成员函数，不能修改类的成员变量</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> constValue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; obj.<span class="built_in">getValue</span>() &lt;&lt; std::endl; <span class="comment">// 合法，调用常量成员函数</span></span><br><span class="line">    <span class="comment">// obj.setValue(5); // 错误，常量对象不能调用非常量成员函数</span></span><br><span class="line">    obj.constValue = <span class="number">5</span>; <span class="comment">// 错误，不能修改 const 成员变量的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="constexper"><a href="#constexper" class="headerlink" title="constexper"></a>constexper</h5><p><code>constexpr</code> 是 C++11 引入的关键字，用于声明“常量表达式”。</p>
<p>常量表达式是在编译时就可以求值的表达式，即它的值可以在编译时被确定。</p>
<p><code>constexpr</code> 可以用于变量、函数、构造函数以及类的成员函数，用于指示它们在编译时就可以被计算出来，而不是在运行时计算。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5是一个常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//square是一个constexpr函数</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">double</span> PI = <span class="number">3.14159</span>;</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Circle</span><span class="params">(<span class="type">double</span> r)</span> : radius(r) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用 <code>constexpr</code> 可以使得程序在编译时进行更多的优化，提高程序的性能。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/12/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stars zhang">
      <meta itemprop="description" content="永远迎着光走">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/12/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">智能指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-12 20:43:40" itemprop="dateCreated datePublished" datetime="2024-04-12T20:43:40+08:00">2024-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-21 22:12:56" itemprop="dateModified" datetime="2024-04-21T22:12:56+08:00">2024-04-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-智能指针"><a href="#1-智能指针" class="headerlink" title="1. 智能指针"></a>1. 智能指针</h1><ul>
<li>智能指针是一种用于管理动态分配的内存的工具，能够帮助避免<strong>内存泄漏</strong>和<strong>悬挂指针</strong>等问题。</li>
<li>智能指针是C++11标准引入的一个重要特性，它们基于RAII（资源获取即初始化）原则，利用对象生命周期的概念，在对象生命周期结束时自动释放资源。</li>
<li>智能指针实际上是一个类对象，它封装了原始指针，并在其生命周期结束时负责释放指针所指向的内存。</li>
<li>智能指针的核心实现技术是引用计数，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。</li>
<li>C++11引入了三种指针：<font color="orange"><code>std::shared_ptr</code>、<code>std::unique_ptr</code>、<code>std::weak_ptr</code></font></li>
</ul>
<h1 id="2-std-shared-ptr"><a href="#2-std-shared-ptr" class="headerlink" title="2. std::shared_ptr"></a>2. std::shared_ptr</h1><p>共享指针，允许多个指针指向同一块内存，它使用<strong>引用计数</strong>来跟踪有多少个指针指向了该对象。并且会在最后一个指针不再指向该内存区域时自动释放资源。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// 使用make_shared创建shared_ptr</span></span><br><span class="line">	std::shared_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    <span class="comment">//或构造函数初始化</span></span><br><span class="line">    std::<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>));</span><br><span class="line">	<span class="comment">// 拷贝复制</span></span><br><span class="line">	std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1; <span class="comment">//引用计数+1</span></span><br><span class="line">	<span class="comment">//获取引用计数</span></span><br><span class="line">	std::cout &lt;&lt;<span class="string">&quot;引用计数：&quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 当ptr1和ptr2都超出作用域时，所管理的内存会被自动释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>创建shared_ptr</strong></p>
<p>使用<code>std::make_shared</code>函数来创建<code>std::shared_ptr</code>，它会自动分配内存并构造对象，同时返回一个指向该对象的<code>std::shared_ptr</code>。</p>
</li>
<li><p><strong>拷贝和赋值</strong></p>
<p>将一个<code>std::shared_ptr</code>赋值给另一个时，引用计数会增加。当所有指向该对象的<code>std::shared_ptr</code>都被销毁时，引用计数会减少。只有当引用计数为0时，资源才会被释放。</p>
</li>
<li><p><strong>引用计数</strong></p>
<p><code>std::shared_ptr</code>内部维护了一个引用计数器，用于跟踪有多少个<code>std::shared_ptr</code>指向了相同的资源。可以通过<code>use_count()</code>方法获取引用计数。</p>
</li>
</ul>
<h1 id="3-std-weak-ptr"><a href="#3-std-weak-ptr" class="headerlink" title="3. std::weak_ptr"></a>3. std::weak_ptr</h1><p>循环引用指的是两个或多个对象彼此之间相互引用，导致它们的引用计数永远不会变为零，从而造成内存泄漏。在使用<code>std::shared_ptr</code>时，循环引用是一个常见的问题，因为<code>std::shared_ptr</code>的引用计数机制可能导致对象永远无法被释放。如以下示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;A&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A 构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A 析构函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;A&gt; a1 = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    std::shared_ptr&lt;A&gt; a2 = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line"></span><br><span class="line">    a1-&gt;next = a2;</span><br><span class="line">    a2-&gt;next = a1; <span class="comment">// 循环引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>a1</code>和<code>a2</code>相互引用，即<code>a1</code>的<code>next</code>指针指向<code>a2</code>，而<code>a2</code>的<code>next</code>指针又指向<code>a1</code>。这样一来，它们之间的引用计数永远不会变为零，因为彼此都在互相引用。即使在<code>main</code>函数结束时，<code>a1</code>和<code>a2</code>的引用计数也不会为零，导致<code>A</code>类对象永远无法被销毁，造成内存泄漏。</p>
<p><code>std::weak_ptr</code>是<code>std::shared_ptr</code>的一种弱引用，它不会增加引用计数。用于解决<code>std::shared_ptr</code>的循环引用带来的内存泄漏问题。可以通过<code>lock()</code>方法获得一个<code>std::shared_ptr</code>，如果原来的<code>std::shared_ptr</code>已经被销毁，则返回一个空指针。</p>
<p>上述示例中，可以将<code>next</code>成员改为<code>std::weak_ptr</code>类型，这样就不会导致循环引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::weak_ptr&lt;A&gt; next; <span class="comment">// 使用weak_ptr</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A 构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A 析构函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;A&gt; a1 = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    std::shared_ptr&lt;A&gt; a2 = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line"></span><br><span class="line">    a1-&gt;next = a2;</span><br><span class="line">    a2-&gt;next = a1; <span class="comment">// 循环引用被打破</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个修改后的示例中，<code>A</code>类的<code>next</code>成员现在是<code>std::weak_ptr</code>类型，这意味着<code>a1-&gt;next</code>和<code>a2-&gt;next</code>不会增加<code>A</code>对象的引用计数。因此，即使<code>a1</code>和<code>a2</code>相互引用，它们之间的循环引用也被打破了。这样在<code>main</code>函数结束时，<code>A</code>类对象的引用计数会变为零，对象会被正确地销毁，从而避免了内存泄漏问题。</p>
<h1 id="4-std-unique-ptr"><a href="#4-std-unique-ptr" class="headerlink" title="4. std::unique_ptr"></a>4. std::unique_ptr</h1><p><code>std::unique_ptr</code>是一种独占所有权的智能指针，它确保在其生命周期内，只有一个指针可以指向该对象。当<code>std::unique_ptr</code>被销毁时，它所管理的对象也会被自动释放。</p>
<ul>
<li>创建unique_ptr</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用make_unique创建unique_ptr</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者使用构造函数</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>移动语义</li>
</ul>
<p><code>std::unique_ptr</code>是独占所有权的，因此它不支持拷贝语义，但支持移动语义。这意味着可以通过移动操作将资源所有权从一个<code>std::unique_ptr</code>转移到另一个。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = std::<span class="built_in">move</span>(ptr1); <span class="comment">// 移动所有权到ptr2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时ptr1不再拥有资源，它指向nullptr</span></span><br><span class="line">    <span class="comment">// ptr2拥有资源，可以安全地使用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>释放资源</li>
</ul>
<p>当<code>std::unique_ptr</code>超出作用域时，它所管理的资源会被自动释放。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    <span class="comment">// 在这里可以安全地使用ptr</span></span><br><span class="line">&#125; <span class="comment">// ptr超出作用域，所管理的内存会被自动释放</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">someFunction</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义删除器</li>
</ul>
<p><code>std::unique_ptr</code>支持自定义删除器，可以指定在释放资源时调用的函数或者函数对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">void customDeleter(int* ptr) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;自定义删除器被调用&quot; &lt;&lt; std::endl;</span><br><span class="line">    delete ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::unique_ptr&lt;int, decltype(&amp;customDeleter)&gt; ptr(new int(42), customDeleter);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/08/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stars zhang">
      <meta itemprop="description" content="永远迎着光走">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/08/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">C++多线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-08 14:16:04" itemprop="dateCreated datePublished" datetime="2024-04-08T14:16:04+08:00">2024-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-10 19:06:05" itemprop="dateModified" datetime="2024-04-10T19:06:05+08:00">2024-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="互斥锁（mutex）"><a href="#互斥锁（mutex）" class="headerlink" title="互斥锁（mutex）"></a>互斥锁（mutex）</h1><p>互斥锁（Mutex）是一种同步机制，用于在多线程程序中保护共享资源，防止多个线程同时访问和修改共享资源而导致竞争条件的发生。<strong>互斥锁通过在对共享资源的访问前先获得锁来确保同一时刻只有一个线程能够访问共享资源，其他线程必须等待该线程释放锁后才能访问。</strong></p>
<p>mutex提供了4种互斥类型：</p>
<ul>
<li>std::mutex：独占的互斥量，不能递归使用，不带超时功能</li>
<li>std::recursive_mutex：递归互斥量，可重入，不带超时功能</li>
<li>std::timed_mutex：带超时的互斥量，不能递归</li>
<li>std::recursive_timed_mutex：带超时的互斥量，可以递归使用</li>
</ul>
<h2 id="1-创建和初始化互斥锁"><a href="#1-创建和初始化互斥锁" class="headerlink" title="1. 创建和初始化互斥锁"></a>1. 创建和初始化互斥锁</h2><p>在C++中，可以使用<code>std::mutex</code>类来创建和使用互斥锁。通常情况下，我们在全局范围内定义一个互斥锁对象，或者在需要保护的共享资源的类中定义一个互斥锁成员变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">std::mutex mtx; <span class="comment">// 全局范围内定义一个互斥锁对象</span></span><br></pre></td></tr></table></figure>

<h2 id="2-加锁和解锁"><a href="#2-加锁和解锁" class="headerlink" title="2. 加锁和解锁"></a>2. 加锁和解锁</h2><p><strong>在访问共享资源之前，线程需要先获取互斥锁，以确保其他线程不会同时访问该资源</strong>。获取锁时，线程会阻塞，直到它成功地获得了锁为止。<strong>使用完共享资源后，线程需要释放锁，以允许其他线程访问该资源。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mtx.<span class="built_in">lock</span>();<span class="comment">// 加锁</span></span><br><span class="line"><span class="comment">/*访问共享资源的代码*/</span></span><br><span class="line">mtx.<span class="built_in">unlock</span>();<span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure>

<h2 id="3-lock-guard"><a href="#3-lock-guard" class="headerlink" title="3. lock_guard"></a>3. lock_guard</h2><p>除了<code>lock()</code>和<code>unlock()</code>方法外，还可以使用<code>std::lock_guard</code>来<strong>自动管理锁的加锁和解锁</strong>。<code>std::lock_guard</code>是一个RAII（资源获取即初始化）类型，它在创建时自动获取锁，在销毁时自动释放锁，从而避免忘记手动解锁而导致的死锁或资源泄漏。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>; <span class="comment">// 自动加锁</span></span><br><span class="line">    <span class="comment">// 访问共享资源的代码</span></span><br><span class="line">&#125; <span class="comment">// 在 guard 超出作用域时自动解锁</span></span><br></pre></td></tr></table></figure>

<p>创建一个名为 <code>guard</code> 的 <code>std::lock_guard</code> 对象，用于管理名为 <code>mtx</code> 的互斥锁。在 <code>lock</code> 对象的作用域结束时，会自动释放 <code>mtx</code> 互斥锁，即使在作用域内发生异常也会自动释放。这样做可以确保互斥锁在不再需要时被正确释放，避免了手动调用 <code>lock()</code> 和 <code>unlock()</code> 方法可能带来的错误和忘记释放锁的风险。</p>
<h2 id="4-unique-lock"><a href="#4-unique-lock" class="headerlink" title="4. unique_lock"></a>4. unique_lock</h2><p><code>std::unique_lock</code> 也是 C++ 标准库提供的一个 RAII 类型，用于管理互斥锁的加锁和解锁，类似于 <code>std::lock_guard</code>。但与 <code>std::lock_guard</code> 不同的是，<code>std::unique_lock</code> 具有更多的灵活性和功能。它可以在<strong>创建时选择是否加锁，也可以手动释放锁，并且可以在未加锁的情况下等待条件变量</strong>。下面详细讲解 <code>std::unique_lock</code> 的用法：</p>
<ol>
<li>创建 <code>std::unique_lock</code> 对象</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 <code>std::unique_lock</code> 自动管理锁</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 自动加锁</span></span><br><span class="line">    <span class="comment">// 访问共享资源的代码</span></span><br><span class="line">&#125; <span class="comment">// 在 lock 超出作用域时自动解锁</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>手动控制加锁和解锁</li>
</ol>
<p><code>std::unique_lock</code> 允许手动控制锁的加锁和解锁。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx, std::defer_lock)</span></span>; <span class="comment">// 不加锁</span></span><br><span class="line">lock.<span class="built_in">lock</span>(); <span class="comment">// 手动加锁</span></span><br><span class="line"><span class="comment">// 访问共享资源的代码</span></span><br><span class="line">lock.<span class="built_in">unlock</span>(); <span class="comment">// 手动解锁</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>std::unique_lock</code> 还可以在未加锁的情况下等待条件变量，从而避免了手动释放锁后再等待条件变量的复杂过程。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::condition_variable cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="comment">// 等待条件变量</span></span><br><span class="line">    cv.<span class="built_in">wait</span>(lock, []&#123; <span class="comment">/* 条件函数 */</span> &#125;);</span><br><span class="line">    <span class="comment">// 条件满足后继续执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::unique_lock</code> 对象 <code>lock</code> 会自动加锁，然后等待条件变量 <code>cv</code>。当条件满足时，会自动解锁并继续执行。</p>
<h1 id="原子操作-atomic"><a href="#原子操作-atomic" class="headerlink" title="原子操作-atomic"></a>原子操作-atomic</h1><p>有两个线程，一个要写数据，一个读数据，如果不加锁可能会造成读写值混乱，使用<code>std::mutex</code>可以使得执行不会导致混乱，但是<strong>每一次循环都要加锁解锁使得程序开销很大</strong>。为了提高性能，C++11提供了原子类型<code>std::atomic</code>，它<strong>提供了多线程间的原子操作</strong>。原子操作是不可分割的操作，要么完全执行，要么完全不执行，不会被其他线程中断。</p>
<p>原子类型是封装了一个值的类型，它的访问保证不会导致数据的竞争，并且可以用于在不同的线程之间同步内存访问。从效率上来说，原子操作要比互斥量的方式效率要高</p>
<ol>
<li>创建 <code>std::atomic</code> 对象</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;atomic&gt;</span><br><span class="line"></span><br><span class="line">std::atomic&lt;int&gt; atomicVariable;</span><br></pre></td></tr></table></figure>

<p>创建了一个名为 <code>atomicVariable</code> 的 <code>std::atomic&lt;int&gt;</code> 对象，表示一个原子的整型变量。</p>
<ol start="2">
<li>原子操作</li>
</ol>
<p><code>std::atomic</code> 提供了一系列原子操作，包括读取、写入、加法、减法等。这些操作可以保证在多线程环境中的原子性，从而避免竞争条件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">atomicVariable.<span class="built_in">store</span>(<span class="number">10</span>); <span class="comment">// 将10存储到原子变量中</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> value = atomicVariable.<span class="built_in">load</span>(); <span class="comment">// 从原子变量中加载值</span></span><br><span class="line"></span><br><span class="line">atomicVariable.<span class="built_in">fetch_add</span>(<span class="number">5</span>); <span class="comment">// 原子地将5加到atomicVariable上</span></span><br><span class="line"></span><br><span class="line">atomicVariable.<span class="built_in">fetch_sub</span>(<span class="number">3</span>); <span class="comment">// 原子地将atomicVariable减3</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> oldValue = atomicVariable.<span class="built_in">exchange</span>(<span class="number">20</span>); <span class="comment">// 原子地将atomicVarible的值交换为 20，并返回之前的值</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>示例</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// 声明一个原子整型变量并初始化为 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">incrementCounter</span><span class="params">(<span class="type">int</span> numIncrements)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numIncrements; ++i) &#123;</span><br><span class="line">        counter++; <span class="comment">// 原子地递增 counter 的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> numThreads = <span class="number">4</span>; <span class="comment">// 定义线程数量</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> numIncrementsPerThread = <span class="number">1000000</span>; <span class="comment">// 每个线程递增的次数</span></span><br><span class="line"></span><br><span class="line">    std::thread threads[numThreads]; <span class="comment">// 创建线程数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动多个线程，并分别调用 incrementCounter 函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; ++i) &#123;</span><br><span class="line">        threads[i] = std::<span class="built_in">thread</span>(incrementCounter, numIncrementsPerThread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程执行完毕</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; ++i) &#123;</span><br><span class="line">        threads[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final value of counter: &quot;</span> &lt;&lt; counter.<span class="built_in">load</span>() &lt;&lt; std::endl; <span class="comment">// 输出最终的 counter 值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Final value of counter: <span class="number">4000000</span></span><br></pre></td></tr></table></figure>

<h1 id="条件变量condition-varible"><a href="#条件变量condition-varible" class="headerlink" title="条件变量condition_varible"></a>条件变量condition_varible</h1><p>用于实现线程之间的<strong>条件等待</strong>和<strong>通知</strong>机制。它通常与 <code>std::mutex</code>（互斥锁）一起使用，用于在某个条件满足时唤醒等待的线程。主要包括两个动作：</p>
<ol>
<li>一个线程等待条件变量的条件成立而挂起(<strong>wait</strong>)</li>
<li>另一个线程使条件成立(<strong>notify_one</strong>，<strong>notify_all</strong>)</li>
</ol>
<p>先来看一个示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> isReady = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">waitingThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">//自动上锁</span></span><br><span class="line">    <span class="keyword">while</span>(!isReady)&#123;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Condition is met, continuing...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(waitingThread)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));<span class="comment">//主线程休眠5秒，模拟主线程工作</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        isReady = <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="comment">// lock超出作用域时自动释放互斥锁</span></span><br><span class="line">    cv.<span class="built_in">notify_one</span>(); <span class="comment">//通知等待的线程</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-等待条件的线程"><a href="#1-等待条件的线程" class="headerlink" title="1. 等待条件的线程"></a>1. 等待条件的线程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">waitingThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">//自动上锁</span></span><br><span class="line">    <span class="keyword">while</span>(!isReady)&#123;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Condition is met, continuing...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它会执行如下步骤：</p>
<ol>
<li><strong>获取与条件变量相关联的互斥锁</strong>。</li>
<li>进入 <code>while</code> 循环，检查条件是否满足。如果条件已经满足，线程会跳过等待，并继续执行后续代码。</li>
<li>如果条件尚未满足，则<strong>调用 <code>cv.wait(lock)</code> 函数，将当前线程置于阻塞状态，并释放互斥锁</strong>。以允许其他线程访问共享资源。</li>
<li>直到<strong>其他线程调用了与条件变量相关联的 <code>notify_one()</code> 或 <code>notify_all()</code> 函数，条件变量被通知。该线程被唤醒，并会重新获取互斥锁</strong>，继续执行whie循环，检查条件是否满足。</li>
<li>如果条件满足，则线程会退出 <code>while</code> 循环，继续执行后续代码。</li>
</ol>
<h2 id="2-设置条件并通知等待的线程"><a href="#2-设置条件并通知等待的线程" class="headerlink" title="2. 设置条件并通知等待的线程"></a>2. 设置条件并通知等待的线程</h2><p>主线程负责设置条件并通知等待的线程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 获取互斥锁</span></span><br><span class="line">isReady = <span class="literal">true</span>;</span><br><span class="line">cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知等待的线程</span></span><br></pre></td></tr></table></figure>

<ol>
<li>在修改条件之前，必须先获得与条件变量关联的互斥锁，并在修改后立即释放锁。</li>
<li>然后，通过 <code>cv.notify_one()</code> 或 <code>cv.notify_all()</code> 来通知等待的线程条件已经发生改变。</li>
</ol>
<h1 id="异步任务-async、future"><a href="#异步任务-async、future" class="headerlink" title="异步任务-async、future"></a>异步任务-async、future</h1><ul>
<li><p>已经有多线程thread了，为什么还要有async?<br>    线程毕竟是属于比较低层次的东西，有时候使用有些不便，比如希望获取线程函数的返回结果的时候，就不能直接通过 <code>thread.join()</code>得到结果，这时就必须定义一个变量，在线程函数中去给这个变量赋值，然后<code>join</code>,最后得到结果，这个过程是比较繁琐的。</p>
</li>
<li><p>C++11 提供了**std::async()**，用于创建异步任务，即在一个新的线程中调用线程函数，并返回一个 <code>std::future</code> 对象，这个<code>future</code>中存储了线程函数返回的结果。</p>
</li>
</ul>
<p>简单示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 耗时操作函数，返回一个整数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">timeConsumingOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟一个耗时操作，这里暂停 2 秒钟</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个异步任务，异步执行 timeConsumingOperation 函数</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fut = std::<span class="built_in">async</span>(std::launch::async, timeConsumingOperation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行其他操作</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Performing other tasks...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待异步操作完成并获取结果</span></span><br><span class="line">    <span class="type">int</span> result = fut.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出异步操作的结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of asynchronous operation: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>概括std::async()的用法：</p>
<h2 id="1-创建异步任务并获取future-对象"><a href="#1-创建异步任务并获取future-对象" class="headerlink" title="1. 创建异步任务并获取future 对象"></a>1. 创建异步任务并获取future 对象</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; fut = std::<span class="built_in">async</span>(std::launch::async, func);</span><br></pre></td></tr></table></figure>

<p>创建了一个异步任务，异步任务会立即在一个新线程中执行，线程调用函数<code>func()</code>，将函数的返回值赋给了<code>future</code>对象<code>fut</code>。</p>
<h2 id="2-获取异步任务的值"><a href="#2-获取异步任务的值" class="headerlink" title="2. 获取异步任务的值"></a>2. 获取异步任务的值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto result = fut.get();</span><br></pre></td></tr></table></figure>

<p>需要获取异步操作的结果时，调用 <code>get()</code> 函数来获取 <code>std::future</code> 对象的值。如果异步操作还没有完成，<code>get()</code> 函数会阻塞当前线程，直到异步操作完成并返回结果。</p>
<p>如何检查异步任务是否完成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> state = fut.<span class="built_in">valid</span>();</span><br></pre></td></tr></table></figure>

<p>可以调用 <code>valid()</code> 函数来检查 <code>std::future</code> 对象是否有效。如果 <code>std::future</code> 对象与异步操作相关联，并且异步操作尚未完成，则 <code>valid()</code> 函数返回 <code>true</code>，否则返回 <code>false</code>。</p>
<h2 id="3-异步执行策略"><a href="#3-异步执行策略" class="headerlink" title="3. 异步执行策略"></a>3. 异步执行策略</h2><p><code>std::async()</code> 函数提供的三种异步执行策略。它们决定了 <code>std::async()</code> 函数创建的异步任务的执行方式。</p>
<h3 id="1-std-launch-async"><a href="#1-std-launch-async" class="headerlink" title="1. std::launch::async"></a>1. std::launch::async</h3><ul>
<li><code>std::launch::async</code> 策略表示创建一个新的线程，在新的线程中异步执行指定的可调用对象。</li>
<li>这意味着异步任务会立即在一个新的线程中执行，不会阻塞当前线程。</li>
<li>使用 <code>std::launch::async</code> 策略创建的异步任务可以实现并行执行，适用于耗时的计算任务和I&#x2F;O操作等。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::future&lt;<span class="type">int</span>&gt; fut = std::<span class="built_in">async</span>(std::launch::async, task);</span><br></pre></td></tr></table></figure>

<h3 id="2-std-launch-deferred"><a href="#2-std-launch-deferred" class="headerlink" title="2. std::launch::deferred"></a>2. std::launch::deferred</h3><ul>
<li><code>std::launch::deferred</code> 策略表示延迟执行指定的可调用对象，直到调用 <code>get()</code> 函数时才在调用线程中执行。</li>
<li>这种策略不会创建新的线程，而是在需要时延迟执行。</li>
<li>使用 <code>std::launch::deferred</code> 策略创建的异步任务不会立即执行，直到调用 <code>get()</code> 函数时才执行，适用于延迟执行和惰性求值等场景。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::future&lt;<span class="type">int</span>&gt; fut = std::<span class="built_in">async</span>(std::launch::deferred, task);</span><br></pre></td></tr></table></figure>

<h3 id="3-std-launch-async-std-launch-deferred"><a href="#3-std-launch-async-std-launch-deferred" class="headerlink" title="3. std::launch::async | std::launch::deferred"></a>3. std::launch::async | std::launch::deferred</h3><ul>
<li><code>std::launch::async | std::launch::deferred</code> 表示由实现自行选择执行策略。</li>
<li>这种策略允许实现根据具体情况自行选择执行方式，可以在新的线程中异步执行，也可以在调用线程中延迟执行。</li>
<li>使用 <code>std::launch::async | std::launch::deferred</code> 策略创建的异步任务有可能在新的线程中执行，也有可能在调用线程中延迟执行，具体取决于实现。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::future&lt;<span class="type">int</span>&gt; fut = std::<span class="built_in">async</span>(std::launch::async | std::launch::deferred, task);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/08/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stars zhang">
      <meta itemprop="description" content="永远迎着光走">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/08/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">十大排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-08 12:00:05" itemprop="dateCreated datePublished" datetime="2024-04-08T12:00:05+08:00">2024-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-17 18:35:50" itemprop="dateModified" datetime="2024-04-17T18:35:50+08:00">2024-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-选择排序"><a href="#1-选择排序" class="headerlink" title="1. 选择排序"></a>1. 选择排序</h1><p>开启n-1轮循环，每次从未排序的元素中选择最小（或最大）的元素，将其与未排序序列的第一个元素交换位置，从而逐步构建有序序列。</p>
<p>选择排序的具体流程如下：</p>
<ol>
<li><strong>初始状态</strong>：将整个序列视为两部分，一部分是已排序序列，另一部分是未排序序列。</li>
<li><strong>选择最小元素</strong>：从未排序序列中选择最小的元素，并将其与未排序序列的第一个元素交换位置。</li>
<li><strong>扩大已排序序列</strong>：将交换后的元素视为已排序序列的一部分，未排序序列减少一个元素。</li>
<li><strong>重复步骤2和步骤3</strong>：直到所有元素都被选择并放置到正确的位置上。</li>
</ol>
<p>伪代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">选择排序(A):</span><br><span class="line">    <span class="keyword">for</span> i from <span class="number">0</span> <span class="function">to <span class="title">length</span><span class="params">(A)</span>-2:</span></span><br><span class="line"><span class="function">        minIndex =</span> i</span><br><span class="line">        <span class="keyword">for</span> j from i+<span class="number">1</span> <span class="function">to <span class="title">length</span><span class="params">(A)</span>-1:</span></span><br><span class="line"><span class="function">            if A[j] &lt; A[minIndex]:</span></span><br><span class="line"><span class="function">                minIndex =</span> j</span><br><span class="line">        <span class="comment">// 将未排序序列中最小元素与第i个元素交换位置</span></span><br><span class="line">        <span class="built_in">swap</span>(A[i], A[minIndex])</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n^2)</p>
<h1 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2. 冒泡排序"></a>2. 冒泡排序</h1><p>多次遍历待排序序列，每轮连续比较相邻的元素，如果“左元素 &gt; 右元素”则交换位置，使较大的元素逐步“冒泡”到数组的末端。</p>
<p>冒泡排序的具体流程如下：</p>
<ol>
<li><strong>比较相邻元素</strong>：从数组的第一个元素开始，比较相邻的两个元素，如果前一个元素比后一个元素大，则交换它们的位置，这样较大的元素就会向数组的末端移动。</li>
<li><strong>遍历整个数组</strong>：重复步骤1，遍历整个数组，直到所有的元素都已经比较过一次。</li>
<li><strong>缩小范围</strong>：每次遍历过程中，都会使得数组末端的一个元素排好序，因此<strong>在下一次遍历时，可以将待排序序列的范围缩小一个元素</strong>。</li>
</ol>
<p>伪代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">冒泡排序(A):</span><br><span class="line">    n = <span class="built_in">length</span>(A)</span><br><span class="line">    <span class="keyword">for</span> i from <span class="number">0</span> to n<span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">for</span> j from <span class="number">0</span> to n<span class="number">-1</span>-i:</span><br><span class="line">            <span class="keyword">if</span> A[j] &gt; A[j+<span class="number">1</span>]:</span><br><span class="line">                <span class="built_in">swap</span>(A[j], A[j+<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<h1 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h1><p>插入排序（Insertion Sort）是一种简单直观的排序算法。其基本思想是<strong>将待排序的数据序列分为已排序区间和未排序区间</strong>，通过构建有序序列，对未排序的数据逐个进行插入，从而达到排序的目的。</p>
<p>插入排序的具体思路如下：</p>
<ol>
<li><strong>初始状态</strong>：将第一个元素视为已排序序列，剩余的元素为未排序序列。</li>
<li><strong>遍历未排序序列</strong>：从第二个元素开始，逐个遍历未排序序列的元素。</li>
<li><strong>将当前元素插入已排序序列</strong>：对于每个未排序序列中的元素，将其与已排序序列中的元素逐个比较，找到合适的位置并插入。</li>
<li><strong>移动元素</strong>：为了给当前元素腾出位置，需要将已排序序列中比当前元素大的元素依次向后移动。</li>
<li><strong>重复步骤3和步骤4</strong>：直到所有元素都被插入到已排序序列中。</li>
</ol>
<p>伪代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">插入排序(A):</span><br><span class="line">    <span class="keyword">for</span> i from <span class="number">1</span> <span class="function">to <span class="title">length</span><span class="params">(A)</span>-1:</span></span><br><span class="line"><span class="function">        currentElement =</span> A[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> A[j] &gt; currentElement:</span><br><span class="line">            A[j+<span class="number">1</span>] = A[j]</span><br><span class="line">            j = j - <span class="number">1</span></span><br><span class="line">        A[j+<span class="number">1</span>] = currentElement</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<h1 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4. 快速排序"></a>4. 快速排序</h1><p>快速排序（quick sort）是一种基于<strong>分治</strong>策略的排序算法。基本思想是<strong>选择一个基准元素，将序列分割成两个子序列，其中一个子序列中的所有元素小于基准元素，另一个子序列中的所有元素大于基准元素，然后对这两个子序列分别进行递归排序。</strong></p>
<p>快速排序的具体步骤如下：</p>
<ol>
<li><strong>选择基准元素</strong>：从待排序序列中选择一个元素作为基准元素。通常选择序列的第一个元素、最后一个元素或者中间的元素作为基准元素。</li>
<li><strong>分割序列</strong>：根据基准元素，将序列分割成两个子序列，其中一个子序列中的元素小于基准元素，另一个子序列中的元素大于基准元素。通常使用两个指针（左指针和右指针）来实现分割，左指针指向序列的起始位置，右指针指向序列的末尾位置，然后从左右两端向中间移动指针，交换不符合条件的元素，直到左右指针相遇。</li>
<li><strong>递归排序</strong>：对两个子序列分别进行递归排序，直到子序列的长度为1或0。</li>
<li><strong>合并结果</strong>：将经过排序的子序列合并成最终的有序序列。</li>
</ol>
<p>伪代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">快速排序(A, low, high):</span><br><span class="line">    <span class="keyword">if</span> low &lt; high:</span><br><span class="line">        pivotIndex = partition(A, low, high)</span><br><span class="line">        快速排序(A, low, pivotIndex - <span class="number">1</span>)</span><br><span class="line">        快速排序(A, pivotIndex + <span class="number">1</span>, high)</span><br><span class="line"></span><br><span class="line">partition(A, low, high):</span><br><span class="line">    pivot = A[low]  // 选择第一个元素作为基准元素</span><br><span class="line">    left = low + <span class="number">1</span></span><br><span class="line">    right = high</span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> A[left] &lt;= pivot:</span><br><span class="line">            left = left + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> A[right] &gt; pivot:</span><br><span class="line">            right = right - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> left &lt; right:</span><br><span class="line">            swap(A[left], A[right])</span><br><span class="line">    swap(A[low], A[right])</span><br><span class="line">    <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure>

<p>快速排序的时间复杂度为 O(n log n)，其中 n 是待排序序列的长度。在平均情况下，快速排序的性能非常好，但是在最坏情况下（例如，当选择的基准元素总是序列中的最大或最小元素时），快速排序的时间复杂度可能会退化为 O(n^2)。</p>
<p>空间复杂度为O(n)：在输入数组完全倒序的情况下，达到最差递归深度 n ，使用 O(n)栈帧空间。若采用<strong>尾递归优化</strong>，则复杂度为O(log n)。</p>
<p>尾递归优化是一种编译器优化技术，用于优化递归调用的栈空间使用。在尾递归优化中，如果函数的最后一个操作是对自身的递归调用，编译器会将这种递归调用转换为循环，从而避免在调用栈上创建新的帧，节省了栈空间的使用。</p>
<h1 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h1><p>归并排序（Merge Sort）是一种基于<strong>分治</strong>思想的排序算法。其基本思路是将待排序序列<strong>分</strong>成两个子序列，分别对这两个子序列进行递归排序，然后将两个已经排好序的子序列<strong>合</strong>并成一个有序序列。</p>
<p>具体的算法流程：</p>
<ol>
<li><strong>分割序列：</strong>不断地将待排序序列划分成两个子序列，直到子序列的长度为1或0</li>
<li><strong>递归排序</strong>：递归地对分割后的两个子序列进行排序。</li>
<li><strong>合并序列：</strong>将两个已经排好序的子序列合并成一个有序序列。</li>
</ol>
<p>伪代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">归并排序(A):</span><br><span class="line">    <span class="keyword">if</span> length(A) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> A</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        middle = length(A) / <span class="number">2</span></span><br><span class="line">        left_half = 归并排序(A[<span class="number">0</span>:middle])  // 递归排序左半部分</span><br><span class="line">        right_half = 归并排序(A[middle:length(A)])  // 递归排序右半部分</span><br><span class="line">        <span class="keyword">return</span> 合并(left_half, right_half)  // 合并左右两部分并返回合并后的有序序列</span><br><span class="line"></span><br><span class="line">合并(left_half, right_half):</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> left_half 不为空 <span class="keyword">and</span> right_half 不为空:</span><br><span class="line">        <span class="keyword">if</span> left_half[<span class="number">0</span>] &lt;= right_half[<span class="number">0</span>]:</span><br><span class="line">            result.append(left_half[<span class="number">0</span>])</span><br><span class="line">            left_half = left_half[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right_half[<span class="number">0</span>])</span><br><span class="line">            right_half = right_half[<span class="number">1</span>:]</span><br><span class="line">    // 将剩余的元素追加到结果中</span><br><span class="line">    result += left_half</span><br><span class="line">    result += right_half</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>归并排序的时间复杂度为 O(n log n)。虽然归并排序的时间复杂度较低，但是需要额外的空间来存储归并过程中产生的临时序列，因此其空间复杂度为 O(n)。</p>
<h1 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6. 堆排序"></a>6. 堆排序</h1><p>堆排序（Heap Sort）是一种基于堆数据结构的排序算法，其基本思想是利用堆的性质实现排序。堆是一个特殊的树形数据结构，具有以下性质：</p>
<ol>
<li>它是一个完全二叉树，即除了最后一层，其他层都是满的。</li>
<li>在一个小顶堆（Min Heap）中，任意节点的值都小于或等于其子节点的值。</li>
<li>在一个大顶堆（Max Heap）中，任意节点的值都大于或等于其子节点的值。</li>
</ol>
<p>将待排序的序列构建成一个大顶堆，重复从堆中取出堆顶元素，并重新构建堆，直到堆为空，最终得到即为排序好的序列。</p>
<p>算法的流程：</p>
<ol>
<li><p>构建堆：</p>
<p>​		首先需要将待排序的序列构建成一个堆。一种常见的方法是从最后一个非叶子节点开始，依次向前进行调整，保证每个节点都满足堆的性质。</p>
<p>大顶堆的调整过程：</p>
<ul>
<li>从最后一个非叶子节点开始（即 n&#x2F;2-1），向前遍历到根节点。</li>
<li>对于每个节点，如果它的子节点中有比它大的，就将其与最大的子节点进行交换，直到它没有比它大的子节点或者到达叶子节点为止。</li>
</ul>
</li>
<li><p>排序：</p>
<p>​		构建好堆之后，需要重复从堆中取出最大（或最小）的元素，并重新调整堆，直到堆为空。具体的过程如下：</p>
<ul>
<li>将堆顶元素（最大或最小值）与堆中的最后一个元素交换位置。</li>
<li>从堆中移除最后一个元素（即最大或最小值）。</li>
<li>对剩余的元素重新调整堆，使其满足堆的性质。</li>
</ul>
<p>重复以上步骤，直到堆为空。</p>
</li>
</ol>
<h1 id="7-桶排序"><a href="#7-桶排序" class="headerlink" title="7. 桶排序"></a>7. 桶排序</h1><h1 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8. 计数排序"></a>8. 计数排序</h1><h1 id="9-基数排序"><a href="#9-基数排序" class="headerlink" title="9. 基数排序"></a>9. 基数排序</h1><h1 id="10-希尔排序"><a href="#10-希尔排序" class="headerlink" title="10. 希尔排序"></a>10. 希尔排序</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/08/%E6%90%9C%E7%B4%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stars zhang">
      <meta itemprop="description" content="永远迎着光走">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/08/%E6%90%9C%E7%B4%A2/" class="post-title-link" itemprop="url">搜索</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-08 10:36:42 / 修改时间：11:05:47" itemprop="dateCreated datePublished" datetime="2024-04-08T10:36:42+08:00">2024-04-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>搜索算法用于在数据结构（例如数组、链表、树或图）中搜索一个或一组满足特定条件的元素。</p>
<p>搜索算法可根据实现思路分为以下两类。</p>
<ul>
<li><strong>通过遍历数据结构来定位目标元素</strong>，例如数组、链表、树和图的遍历等。</li>
<li><strong>利用数据组织结构或数据包含的先验信息，实现高效元素查找</strong>，例如二分查找、哈希查找和二叉搜索树查找等。</li>
</ul>
<h1 id="1-暴力搜索"><a href="#1-暴力搜索" class="headerlink" title="1. 暴力搜索"></a>1. 暴力搜索</h1><p>暴力搜索通过遍历数据结构的每个元素来定位目标元素。</p>
<h2 id="1-线性搜索"><a href="#1-线性搜索" class="headerlink" title="1. 线性搜索"></a>1. 线性搜索</h2><ul>
<li>适用于<strong>数组</strong>和<strong>链表</strong>等线性数据结构。</li>
<li>顺序地逐个检查数据结构中的每个元素，直到找到目标元素或搜索完整个数据结构。</li>
<li>时间复杂度为**O(n)**，其中n是数据结构中的元素数量。</li>
</ul>
<h2 id="2-图搜索"><a href="#2-图搜索" class="headerlink" title="2. 图搜索"></a>2. 图搜索</h2><ul>
<li>用于在图&#x2F;树中查找特定的节点或路径，即<strong>深度优先搜索（Depth-First Search，DFS）</strong>和<strong>广度优先搜索（Breadth-First Search，BFS）</strong></li>
<li>广度优先搜索从初始节点开始逐层搜索，由近及远地访问各个节点。</li>
<li>深度优先搜索从初始节点开始，沿着一条路径走到头，再回溯并尝试其他路径，直到遍历完整个数据结构。</li>
<li>时间复杂度取决于图的结构和算法的实现方式。</li>
</ul>
<h1 id="2-自适应搜索"><a href="#2-自适应搜索" class="headerlink" title="2. 自适应搜索"></a>2. 自适应搜索</h1><p>自适应搜索利用数据的特有属性（例如有序性）来优化搜索过程，从而更高效地定位目标元素。</p>
<h2 id="1-二分搜索"><a href="#1-二分搜索" class="headerlink" title="1. 二分搜索"></a>1. 二分搜索</h2><ul>
<li>仅适用于已排序的数据结构（如有序数组），通过不断将搜索范围减半来定位目标元素。</li>
<li>时间复杂度为**O(log n)**。</li>
</ul>
<h2 id="2-哈希查找"><a href="#2-哈希查找" class="headerlink" title="2. 哈希查找"></a>2. <strong>哈希查找</strong></h2><ul>
<li>利用哈希表将<strong>搜索数据</strong>和<strong>目标数据</strong>建立为<strong>键值对映射</strong>，从而实现查询操作。</li>
<li>时间复杂度通常为**O(1)**，但在冲突较多的情况下可能会降低到O(n)。</li>
</ul>
<h2 id="3-树查找"><a href="#3-树查找" class="headerlink" title="3. 树查找"></a>3. 树查找</h2><ul>
<li>通过<strong>有序的树结构</strong>和特定的查找算法（如递归或迭代）来查找目标元素。</li>
<li>包括<strong>二叉搜索树（Binary Search Tree，BST）、平衡二叉树（Balanced Binary Tree，如AVL树、红黑树）、B树等</strong>。</li>
<li>平均情况下的时间复杂度取决于树的高度，**通常为O(log n)**，但在最坏情况下可能为O(n)。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/07/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stars zhang">
      <meta itemprop="description" content="永远迎着光走">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/07/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/" class="post-title-link" itemprop="url">浅拷贝与深拷贝</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-07 13:04:49 / 修改时间：13:59:15" itemprop="dateCreated datePublished" datetime="2024-04-07T13:04:49+08:00">2024-04-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><ul>
<li>简单的拷贝对象成员变量的值，而不拷贝对象所指向的动态分配的内存。</li>
<li>因此，新旧对象的指针成员指向相同内存地址的指针，它们将共享同一块内存，可能导致潜在的问题。</li>
<li>如果其中一个对象销毁了这个指针指向的内存，另一个对象可能会引用已经无效的内存地址。</li>
<li>当一个对象发生改变时，由于另一个对象与之共享同一块内存，另一个对象也会受到影响。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShallowCopy</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ShallowCopy</span>(<span class="type">int</span> val) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="built_in">int</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ShallowCopy</span>(<span class="type">const</span> ShallowCopy &amp;other) &#123;</span><br><span class="line">        data = other.data; <span class="comment">// 进行浅拷贝</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;shallow copy&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getData</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setData</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        *data = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ShallowCopy</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ShallowCopy <span class="title">a1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    ShallowCopy a2 = a1;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1=&quot;</span> &lt;&lt; a1.<span class="built_in">getData</span>() &lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;a2=&quot;</span> &lt;&lt; a2.<span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    a1.<span class="built_in">setData</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1=&quot;</span> &lt;&lt; a1.<span class="built_in">getData</span>() &lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;a2=&quot;</span> &lt;&lt; a2.<span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shallow copy</span><br><span class="line">a1=<span class="number">5</span> a2=<span class="number">5</span></span><br><span class="line">a1=<span class="number">10</span> a2=<span class="number">10</span></span><br></pre></td></tr></table></figure>

<h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><ul>
<li>不仅拷贝对象本身，还拷贝对象所指向的动态分配的内存，以确保拷贝后的对象和原对象指向的内存是独立的。</li>
<li>深拷贝会为新的对象分配一块新的内存，并将原对象所指向的内存的内容复制到新分配的内存中，从而使得新旧对象完全独立，互不影响。</li>
<li>即使两个对象有相同的值，它们也各自拥有一份独立的内存副本，彼此互不影响。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeepCopy</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DeepCopy</span>(<span class="type">int</span> val) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="built_in">int</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DeepCopy</span>(<span class="type">const</span> DeepCopy &amp;other) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">        *data = *(other.data); <span class="comment">// 进行深拷贝</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;deep copy&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getData</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setData</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        *data = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">DeepCopy</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">DeepCopy <span class="title">b1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">DeepCopy <span class="title">b2</span><span class="params">(b1)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b1=&quot;</span> &lt;&lt; b1.<span class="built_in">getData</span>() &lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;b2=&quot;</span> &lt;&lt; b2.<span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    b1.<span class="built_in">setData</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b1=&quot;</span> &lt;&lt; b1.<span class="built_in">getData</span>() &lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;b2=&quot;</span> &lt;&lt; b2.<span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deep copy</span><br><span class="line">b1=<span class="number">5</span> b2=<span class="number">5</span></span><br><span class="line">b1=<span class="number">10</span> b2=<span class="number">5</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/07/%E5%B7%A6%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stars zhang">
      <meta itemprop="description" content="永远迎着光走">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/07/%E5%B7%A6%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/" class="post-title-link" itemprop="url">左右值引用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-07 12:32:40" itemprop="dateCreated datePublished" datetime="2024-04-07T12:32:40+08:00">2024-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-10 10:13:53" itemprop="dateModified" datetime="2024-04-10T10:13:53+08:00">2024-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-左值、右值"><a href="#1-左值、右值" class="headerlink" title="1. 左值、右值"></a>1. 左值、右值</h1><h2 id="左值："><a href="#左值：" class="headerlink" title="左值："></a>左值：</h2><ul>
<li>表达式结束后依然存在的<strong>持久性对象</strong>或者函数，可以被取地址。</li>
<li>左值是可以被标识符引用的表达式，它们代表着内存中的一个位置。例如，变量、数组元素、通过引用或指针访问的对象、具有名称的对象等都是左值。</li>
<li>左值在赋值操作符左侧出现，可以接受赋值操作。</li>
</ul>
<h2 id="右值："><a href="#右值：" class="headerlink" title="右值："></a>右值：</h2><ul>
<li>表达式结束后就消失的<strong>临时对象</strong>，通常不能被取地址。</li>
<li>右值是不具有持久性的临时对象或者表达式的结果，不能被直接引用。例如，字面常量、临时对象、未命名的临时对象、返回临时对象的函数调用等都是右值。</li>
<li>右值通常出现在赋值操作符右侧，用于提供值给赋值操作。</li>
</ul>
<h1 id="2-左值引用、右值引用"><a href="#2-左值引用、右值引用" class="headerlink" title="2. 左值引用、右值引用"></a>2. 左值引用、右值引用</h1><h2 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h2><ul>
<li>左值引用是通过使用 <code>&amp;</code> 符号声明的引用类型。它绑定到左值，并且可以延长左值的生命周期，使得左值可以在函数调用等情况下被修改。</li>
<li>左值引用不能绑定到右值。</li>
<li>左值引用常用于函数参数传递、函数返回值和操作符重载等场景，可以实现有效的引用语义和避免不必要的拷贝。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a; <span class="comment">// b是左值引用</span></span><br><span class="line">b = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> &amp;c = <span class="number">10</span>; <span class="comment">// error，10无法取地址，无法进行引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;d = <span class="number">10</span>; <span class="comment">// ok，因为是常引用，引用常量数字，这个常量数字会存储在内存中，可以取地址</span></span><br></pre></td></tr></table></figure>

<p>可以得出结论：对于左值引用，等号右边的值必须可以取地址，如果不能取地址，则会编译失败，或者可以使用const引用形式，但这样就只能通过引用来读取输出，不能修改数组，因为是常量引用。</p>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><ul>
<li>右值引用是通过使用 <code>&amp;&amp;</code> 符号声明的引用类型。它主要用于绑定到临时对象或者即将销毁的对象，允许移动语义的使用。</li>
<li>右值引用可以绑定到右值，但不能绑定到左值。</li>
<li>右值引用的引入使得可以实现移动语义，即将资源从一个对象“移动”到另一个对象，而不是进行昂贵的拷贝操作。这在处理临时对象时尤为有用，能够提高性能。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;&#125; <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; other) &#123;&#125; <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp; other) &#123;&#125; <span class="comment">// 移动构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">createA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">A</span>(); <span class="comment">// 返回一个临时对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a1 = <span class="built_in">createA</span>(); <span class="comment">// 调用移动构造函数，避免了拷贝</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>std::move函数：把一个左值强制转换成一个右值 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> &amp;&amp;b = a; <span class="comment">// error, a是左值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;c = std::<span class="built_in">move</span>(a); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<h1 id="3-移动语义"><a href="#3-移动语义" class="headerlink" title="3. 移动语义"></a>3. 移动语义</h1><ul>
<li>利用右值引用允许在对象间转移资源的所有权，而不是传统的拷贝。</li>
<li>这种转移资源的操作比拷贝操作更高效，特别是对于动态分配的内存或者其他资源。</li>
<li>移动语义的引入是为了解决传统的拷贝操作在处理临时对象时可能造成性能开销的问题。</li>
<li>移动语义的核心概念在于，当一个对象被标记为将要被销毁（右值），它的资源可以被安全地“窃取”到另一个对象，而不是简单地复制。这意味着移动操作将对象的资源所有权从一个对象转移到另一个对象，而不会发生资源的复制或者额外的分配。</li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol>
<li>避免不必要的拷贝操作</li>
<li>实现资源管理的高效转移</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Resource</span>() &#123;&#125;</span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">Resource</span>(Resource&amp;&amp; other) &#123;</span><br><span class="line">        <span class="comment">// 窃取资源</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;data = other.data;</span><br><span class="line">        other.data = <span class="literal">nullptr</span>; <span class="comment">// 将原始对象置为空，避免资源重复释放</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Resource res1;</span><br><span class="line">    Resource res2 = std::<span class="built_in">move</span>(res1); <span class="comment">// 调用移动构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-完美转发"><a href="#4-完美转发" class="headerlink" title="4. 完美转发"></a>4. 完美转发</h1><ul>
<li>允许将参数传递到另一个函数，并保留原始参数的值类别（左值或右值）和const修饰符。</li>
<li>目标是在保留参数类型的同时，将参数转发给其他函数，实现通用性更强的函数包装或者委托。</li>
<li>完美转发的关键是使用了<strong>右值引用</strong>和<strong>模板参数</strong>推导。通过使用 <code>std::forward</code> 函数模板，可以在传递参数时保留参数的值类别，确保参数被按原样传递。这种机制在实现泛型编程时尤为有用，可以减少代码的重复和增加可读性。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// arg 是右值引用或者左值引用，依据传递的实参类型决定</span></span><br><span class="line">    <span class="comment">// 将参数 arg 转发给另一个函数 foo()</span></span><br><span class="line">    <span class="built_in">foo</span>(std::forward&lt;T&gt;(arg)); <span class="comment">// 完美转发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123; </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;left value&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123; </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;right value&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">wrapper</span>(x); <span class="comment">// 传递左值</span></span><br><span class="line">    <span class="built_in">wrapper</span>(<span class="number">42</span>); <span class="comment">// 传递右值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>wrapper</code> 函数模板通过 <code>std::forward</code> 将参数 <code>arg</code> 完美转发给 <code>foo</code> 函数。无论 <code>arg</code> 是左值还是右值，都可以在 <code>foo</code> 中保持其原始的属性，并且正确地调用对应的 <code>foo</code> 函数重载。</p>
<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">42</span>: left value</span><br><span class="line"><span class="number">42</span>: right value</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/05/%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stars zhang">
      <meta itemprop="description" content="永远迎着光走">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/05/%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8/" class="post-title-link" itemprop="url">指针和引用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-05 15:24:45" itemprop="dateCreated datePublished" datetime="2024-04-05T15:24:45+08:00">2024-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-06 15:40:28" itemprop="dateModified" datetime="2024-05-06T15:40:28+08:00">2024-05-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="一、区别"><a href="#一、区别" class="headerlink" title="一、区别"></a>一、区别</h4><h5 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h5><p>（1）指针是一个变量，其值为另一个变量的地址，指向内存的一个存储单元。是一个对象实体</p>
<p>（2）而引用的本质是给变量起别名，允许通过这个别名去直接操纵和修改对象本身的属性。引用跟原来的变量实质上是同一个东西。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//指针</span></span><br><span class="line"><span class="type">int</span>* p = &amp;a;</span><br><span class="line"><span class="comment">//引用</span></span><br><span class="line"><span class="type">int</span>&amp; b = a;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-空指针与无效引用"><a href="#1-2-空指针与无效引用" class="headerlink" title="1.2 空指针与无效引用"></a>1.2 空指针与无效引用</h5><p>（1）指针可以为空，表示它不指向任何有效的内存地址。在指针没有被初始化时，它的值通常是未定义的，为了避免错误，可以将其初始化为 <code>nullptr</code> 或 <code>NULL</code>。</p>
<p>（2）引用不能为空，它必须在声明时被初始化，并且始终指向某个对象。试图将引用声明为 null 或者空值会导致编译错误。</p>
<h5 id="1-3-初始化"><a href="#1-3-初始化" class="headerlink" title="1.3 初始化"></a>1.3 初始化</h5><p>（1）指针需要进行初始化，可以使用取地址符号 <code>&amp;</code> 来获取一个变量的地址，也可以将另一个指针赋值给它。</p>
<p>（2）引用在声明时必须初始化，而且一旦初始化后，不能被重新绑定到其他变量。</p>
<ol start="4">
<li>运算符</li>
</ol>
<p>（1）指针可以通过解引用 <code>*</code> 运算符来访问所指向的对象，也可以使用箭头 <code>-&gt;</code> 运算符来访问成员，例如：<code>p-&gt;member</code>。</p>
<p>（2）引用则不需要解引用操作符，因为它们在使用时就是被解引用的。例如：<code>b.member</code>。</p>
<h4 id="二、指针常量、常量指针、引用"><a href="#二、指针常量、常量指针、引用" class="headerlink" title="二、指针常量、常量指针、引用"></a>二、指针常量、常量指针、引用</h4><ol>
<li><p>指针常量：表示这个指针是一个常量，指针的值不可修改。</p>
<p>如 <code>int* const p</code>，表示一个指向整数类型的指针常量。</p>
</li>
</ol>
<ul>
<li><code>int*</code>：表示指向整数类型的指针。这意味着 <code>p</code> 是一个指针，可以存储整数类型变量的地址。</li>
<li><code>const</code>：表示常量，这里用于修饰指针。<code>const</code> 关键字使得指针变量成为一个常量，即<strong>指针的值（地址）不能被修改，但是可以通过 <code>p</code> 修改它所指向的整数值。</strong></li>
</ul>
<ol start="2">
<li><p>常量指针：表示该指针指向的值是一个常量，不可修改。</p>
<p>如 <code>const int* p</code>，表示一个指向整数常量的指针。</p>
</li>
</ol>
<ul>
<li><code>const</code>：表示常量，这里用于修饰整数类型。<code>const</code> 关键字使得指针所指向的整数值为常量，即<strong>不能通过 <code>p</code> 修改它所指向的整数值。</strong></li>
<li><code>int*</code>：表示指向整数类型的指针。这意味着 <code>p</code> 是一个指针，<strong>可以更改指针的指向，让其指向其他值</strong>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int x = 10;</span><br><span class="line">int y = 20;</span><br><span class="line"></span><br><span class="line">int* const p1 = &amp;x;  // p 是一个指向整数类型的指针常量，指向 x 的地址</span><br><span class="line">*p1 = 15;            // 合法，修改了 p 指向的整数变量 x 的值</span><br><span class="line">// p1 = &amp;y;         // 不合法，试图修改 p 的值（地址），但 p 是一个常量，其值不能修改</span><br><span class="line"></span><br><span class="line">const int z = 20;</span><br><span class="line">const int* p2 = &amp;x;  // p 是一个指向常量整数类型的指针，指向 x 的地址</span><br><span class="line">// *p2 = 15;         // 不合法，试图通过 p 修改其所指向的整数值，但整数值是常量，不能修改</span><br><span class="line">p2 = &amp;z;             // 合法，修改 p 指向的地址，但是 p 仍然指向一个整数类型的常量</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>引用的本质在c++内部实现是一个指针常量.</strong> 即可以通过引用修改原变量值，但引用不能更改绑定其他变量。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; b = a;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> b = &amp;a;</span><br></pre></td></tr></table></figure>

<h4 id="三、区分下列指针类型"><a href="#三、区分下列指针类型" class="headerlink" title="三、区分下列指针类型"></a>三、区分下列指针类型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p[<span class="number">10</span>]</span><br></pre></td></tr></table></figure>

<p>表示指针数组，是一个大小为10的数组，数组元素为int *类型的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">10</span>]</span><br></pre></td></tr></table></figure>

<p>表示一个数组指针，该指针指向一个大小为10，元素类型为int的数组首地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">p</span><span class="params">(<span class="type">int</span>)</span></span><br></pre></td></tr></table></figure>

<p>表示一个函数声明，函数返回值类型为int*，函数名为p，传入参数类型为int</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>表示一个函数指针，即p是一个指向函数的指针，该函数接受一个int类型的参数，且返回值为int</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">stars zhang</p>
  <div class="site-description" itemprop="description">永远迎着光走</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">stars zhang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
