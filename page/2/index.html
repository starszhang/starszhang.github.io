<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="永远迎着光走">
<meta property="og:type" content="website">
<meta property="og:title" content="stars">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="stars">
<meta property="og:description" content="永远迎着光走">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="stars zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>stars</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">stars</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/08/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stars zhang">
      <meta itemprop="description" content="永远迎着光走">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/08/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">C++多线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-08 14:16:04" itemprop="dateCreated datePublished" datetime="2024-04-08T14:16:04+08:00">2024-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-10 19:06:05" itemprop="dateModified" datetime="2024-04-10T19:06:05+08:00">2024-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="互斥锁（mutex）"><a href="#互斥锁（mutex）" class="headerlink" title="互斥锁（mutex）"></a>互斥锁（mutex）</h1><p>互斥锁（Mutex）是一种同步机制，用于在多线程程序中保护共享资源，防止多个线程同时访问和修改共享资源而导致竞争条件的发生。<strong>互斥锁通过在对共享资源的访问前先获得锁来确保同一时刻只有一个线程能够访问共享资源，其他线程必须等待该线程释放锁后才能访问。</strong></p>
<p>mutex提供了4种互斥类型：</p>
<ul>
<li>std::mutex：独占的互斥量，不能递归使用，不带超时功能</li>
<li>std::recursive_mutex：递归互斥量，可重入，不带超时功能</li>
<li>std::timed_mutex：带超时的互斥量，不能递归</li>
<li>std::recursive_timed_mutex：带超时的互斥量，可以递归使用</li>
</ul>
<h2 id="1-创建和初始化互斥锁"><a href="#1-创建和初始化互斥锁" class="headerlink" title="1. 创建和初始化互斥锁"></a>1. 创建和初始化互斥锁</h2><p>在C++中，可以使用<code>std::mutex</code>类来创建和使用互斥锁。通常情况下，我们在全局范围内定义一个互斥锁对象，或者在需要保护的共享资源的类中定义一个互斥锁成员变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">std::mutex mtx; <span class="comment">// 全局范围内定义一个互斥锁对象</span></span><br></pre></td></tr></table></figure>

<h2 id="2-加锁和解锁"><a href="#2-加锁和解锁" class="headerlink" title="2. 加锁和解锁"></a>2. 加锁和解锁</h2><p><strong>在访问共享资源之前，线程需要先获取互斥锁，以确保其他线程不会同时访问该资源</strong>。获取锁时，线程会阻塞，直到它成功地获得了锁为止。<strong>使用完共享资源后，线程需要释放锁，以允许其他线程访问该资源。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mtx.<span class="built_in">lock</span>();<span class="comment">// 加锁</span></span><br><span class="line"><span class="comment">/*访问共享资源的代码*/</span></span><br><span class="line">mtx.<span class="built_in">unlock</span>();<span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure>

<h2 id="3-lock-guard"><a href="#3-lock-guard" class="headerlink" title="3. lock_guard"></a>3. lock_guard</h2><p>除了<code>lock()</code>和<code>unlock()</code>方法外，还可以使用<code>std::lock_guard</code>来<strong>自动管理锁的加锁和解锁</strong>。<code>std::lock_guard</code>是一个RAII（资源获取即初始化）类型，它在创建时自动获取锁，在销毁时自动释放锁，从而避免忘记手动解锁而导致的死锁或资源泄漏。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>; <span class="comment">// 自动加锁</span></span><br><span class="line">    <span class="comment">// 访问共享资源的代码</span></span><br><span class="line">&#125; <span class="comment">// 在 guard 超出作用域时自动解锁</span></span><br></pre></td></tr></table></figure>

<p>创建一个名为 <code>guard</code> 的 <code>std::lock_guard</code> 对象，用于管理名为 <code>mtx</code> 的互斥锁。在 <code>lock</code> 对象的作用域结束时，会自动释放 <code>mtx</code> 互斥锁，即使在作用域内发生异常也会自动释放。这样做可以确保互斥锁在不再需要时被正确释放，避免了手动调用 <code>lock()</code> 和 <code>unlock()</code> 方法可能带来的错误和忘记释放锁的风险。</p>
<h2 id="4-unique-lock"><a href="#4-unique-lock" class="headerlink" title="4. unique_lock"></a>4. unique_lock</h2><p><code>std::unique_lock</code> 也是 C++ 标准库提供的一个 RAII 类型，用于管理互斥锁的加锁和解锁，类似于 <code>std::lock_guard</code>。但与 <code>std::lock_guard</code> 不同的是，<code>std::unique_lock</code> 具有更多的灵活性和功能。它可以在<strong>创建时选择是否加锁，也可以手动释放锁，并且可以在未加锁的情况下等待条件变量</strong>。下面详细讲解 <code>std::unique_lock</code> 的用法：</p>
<ol>
<li>创建 <code>std::unique_lock</code> 对象</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 <code>std::unique_lock</code> 自动管理锁</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 自动加锁</span></span><br><span class="line">    <span class="comment">// 访问共享资源的代码</span></span><br><span class="line">&#125; <span class="comment">// 在 lock 超出作用域时自动解锁</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>手动控制加锁和解锁</li>
</ol>
<p><code>std::unique_lock</code> 允许手动控制锁的加锁和解锁。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx, std::defer_lock)</span></span>; <span class="comment">// 不加锁</span></span><br><span class="line">lock.<span class="built_in">lock</span>(); <span class="comment">// 手动加锁</span></span><br><span class="line"><span class="comment">// 访问共享资源的代码</span></span><br><span class="line">lock.<span class="built_in">unlock</span>(); <span class="comment">// 手动解锁</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>std::unique_lock</code> 还可以在未加锁的情况下等待条件变量，从而避免了手动释放锁后再等待条件变量的复杂过程。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::condition_variable cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="comment">// 等待条件变量</span></span><br><span class="line">    cv.<span class="built_in">wait</span>(lock, []&#123; <span class="comment">/* 条件函数 */</span> &#125;);</span><br><span class="line">    <span class="comment">// 条件满足后继续执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::unique_lock</code> 对象 <code>lock</code> 会自动加锁，然后等待条件变量 <code>cv</code>。当条件满足时，会自动解锁并继续执行。</p>
<h1 id="原子操作-atomic"><a href="#原子操作-atomic" class="headerlink" title="原子操作-atomic"></a>原子操作-atomic</h1><p>有两个线程，一个要写数据，一个读数据，如果不加锁可能会造成读写值混乱，使用<code>std::mutex</code>可以使得执行不会导致混乱，但是<strong>每一次循环都要加锁解锁使得程序开销很大</strong>。为了提高性能，C++11提供了原子类型<code>std::atomic</code>，它<strong>提供了多线程间的原子操作</strong>。原子操作是不可分割的操作，要么完全执行，要么完全不执行，不会被其他线程中断。</p>
<p>原子类型是封装了一个值的类型，它的访问保证不会导致数据的竞争，并且可以用于在不同的线程之间同步内存访问。从效率上来说，原子操作要比互斥量的方式效率要高</p>
<ol>
<li>创建 <code>std::atomic</code> 对象</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;atomic&gt;</span><br><span class="line"></span><br><span class="line">std::atomic&lt;int&gt; atomicVariable;</span><br></pre></td></tr></table></figure>

<p>创建了一个名为 <code>atomicVariable</code> 的 <code>std::atomic&lt;int&gt;</code> 对象，表示一个原子的整型变量。</p>
<ol start="2">
<li>原子操作</li>
</ol>
<p><code>std::atomic</code> 提供了一系列原子操作，包括读取、写入、加法、减法等。这些操作可以保证在多线程环境中的原子性，从而避免竞争条件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">atomicVariable.<span class="built_in">store</span>(<span class="number">10</span>); <span class="comment">// 将10存储到原子变量中</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> value = atomicVariable.<span class="built_in">load</span>(); <span class="comment">// 从原子变量中加载值</span></span><br><span class="line"></span><br><span class="line">atomicVariable.<span class="built_in">fetch_add</span>(<span class="number">5</span>); <span class="comment">// 原子地将5加到atomicVariable上</span></span><br><span class="line"></span><br><span class="line">atomicVariable.<span class="built_in">fetch_sub</span>(<span class="number">3</span>); <span class="comment">// 原子地将atomicVariable减3</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> oldValue = atomicVariable.<span class="built_in">exchange</span>(<span class="number">20</span>); <span class="comment">// 原子地将atomicVarible的值交换为 20，并返回之前的值</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>示例</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// 声明一个原子整型变量并初始化为 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">incrementCounter</span><span class="params">(<span class="type">int</span> numIncrements)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numIncrements; ++i) &#123;</span><br><span class="line">        counter++; <span class="comment">// 原子地递增 counter 的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> numThreads = <span class="number">4</span>; <span class="comment">// 定义线程数量</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> numIncrementsPerThread = <span class="number">1000000</span>; <span class="comment">// 每个线程递增的次数</span></span><br><span class="line"></span><br><span class="line">    std::thread threads[numThreads]; <span class="comment">// 创建线程数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动多个线程，并分别调用 incrementCounter 函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; ++i) &#123;</span><br><span class="line">        threads[i] = std::<span class="built_in">thread</span>(incrementCounter, numIncrementsPerThread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程执行完毕</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numThreads; ++i) &#123;</span><br><span class="line">        threads[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final value of counter: &quot;</span> &lt;&lt; counter.<span class="built_in">load</span>() &lt;&lt; std::endl; <span class="comment">// 输出最终的 counter 值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Final value of counter: <span class="number">4000000</span></span><br></pre></td></tr></table></figure>

<h1 id="条件变量condition-varible"><a href="#条件变量condition-varible" class="headerlink" title="条件变量condition_varible"></a>条件变量condition_varible</h1><p>用于实现线程之间的<strong>条件等待</strong>和<strong>通知</strong>机制。它通常与 <code>std::mutex</code>（互斥锁）一起使用，用于在某个条件满足时唤醒等待的线程。主要包括两个动作：</p>
<ol>
<li>一个线程等待条件变量的条件成立而挂起(<strong>wait</strong>)</li>
<li>另一个线程使条件成立(<strong>notify_one</strong>，<strong>notify_all</strong>)</li>
</ol>
<p>先来看一个示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> isReady = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">waitingThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">//自动上锁</span></span><br><span class="line">    <span class="keyword">while</span>(!isReady)&#123;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Condition is met, continuing...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(waitingThread)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));<span class="comment">//主线程休眠5秒，模拟主线程工作</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        isReady = <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="comment">// lock超出作用域时自动释放互斥锁</span></span><br><span class="line">    cv.<span class="built_in">notify_one</span>(); <span class="comment">//通知等待的线程</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-等待条件的线程"><a href="#1-等待条件的线程" class="headerlink" title="1. 等待条件的线程"></a>1. 等待条件的线程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">waitingThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">//自动上锁</span></span><br><span class="line">    <span class="keyword">while</span>(!isReady)&#123;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Condition is met, continuing...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它会执行如下步骤：</p>
<ol>
<li><strong>获取与条件变量相关联的互斥锁</strong>。</li>
<li>进入 <code>while</code> 循环，检查条件是否满足。如果条件已经满足，线程会跳过等待，并继续执行后续代码。</li>
<li>如果条件尚未满足，则<strong>调用 <code>cv.wait(lock)</code> 函数，将当前线程置于阻塞状态，并释放互斥锁</strong>。以允许其他线程访问共享资源。</li>
<li>直到<strong>其他线程调用了与条件变量相关联的 <code>notify_one()</code> 或 <code>notify_all()</code> 函数，条件变量被通知。该线程被唤醒，并会重新获取互斥锁</strong>，继续执行whie循环，检查条件是否满足。</li>
<li>如果条件满足，则线程会退出 <code>while</code> 循环，继续执行后续代码。</li>
</ol>
<h2 id="2-设置条件并通知等待的线程"><a href="#2-设置条件并通知等待的线程" class="headerlink" title="2. 设置条件并通知等待的线程"></a>2. 设置条件并通知等待的线程</h2><p>主线程负责设置条件并通知等待的线程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 获取互斥锁</span></span><br><span class="line">isReady = <span class="literal">true</span>;</span><br><span class="line">cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知等待的线程</span></span><br></pre></td></tr></table></figure>

<ol>
<li>在修改条件之前，必须先获得与条件变量关联的互斥锁，并在修改后立即释放锁。</li>
<li>然后，通过 <code>cv.notify_one()</code> 或 <code>cv.notify_all()</code> 来通知等待的线程条件已经发生改变。</li>
</ol>
<h1 id="异步任务-async、future"><a href="#异步任务-async、future" class="headerlink" title="异步任务-async、future"></a>异步任务-async、future</h1><ul>
<li><p>已经有多线程thread了，为什么还要有async?<br>    线程毕竟是属于比较低层次的东西，有时候使用有些不便，比如希望获取线程函数的返回结果的时候，就不能直接通过 <code>thread.join()</code>得到结果，这时就必须定义一个变量，在线程函数中去给这个变量赋值，然后<code>join</code>,最后得到结果，这个过程是比较繁琐的。</p>
</li>
<li><p>C++11 提供了**std::async()**，用于创建异步任务，即在一个新的线程中调用线程函数，并返回一个 <code>std::future</code> 对象，这个<code>future</code>中存储了线程函数返回的结果。</p>
</li>
</ul>
<p>简单示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 耗时操作函数，返回一个整数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">timeConsumingOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟一个耗时操作，这里暂停 2 秒钟</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个异步任务，异步执行 timeConsumingOperation 函数</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fut = std::<span class="built_in">async</span>(std::launch::async, timeConsumingOperation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行其他操作</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Performing other tasks...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待异步操作完成并获取结果</span></span><br><span class="line">    <span class="type">int</span> result = fut.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出异步操作的结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of asynchronous operation: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>概括std::async()的用法：</p>
<h2 id="1-创建异步任务并获取future-对象"><a href="#1-创建异步任务并获取future-对象" class="headerlink" title="1. 创建异步任务并获取future 对象"></a>1. 创建异步任务并获取future 对象</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; fut = std::<span class="built_in">async</span>(std::launch::async, func);</span><br></pre></td></tr></table></figure>

<p>创建了一个异步任务，异步任务会立即在一个新线程中执行，线程调用函数<code>func()</code>，将函数的返回值赋给了<code>future</code>对象<code>fut</code>。</p>
<h2 id="2-获取异步任务的值"><a href="#2-获取异步任务的值" class="headerlink" title="2. 获取异步任务的值"></a>2. 获取异步任务的值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto result = fut.get();</span><br></pre></td></tr></table></figure>

<p>需要获取异步操作的结果时，调用 <code>get()</code> 函数来获取 <code>std::future</code> 对象的值。如果异步操作还没有完成，<code>get()</code> 函数会阻塞当前线程，直到异步操作完成并返回结果。</p>
<p>如何检查异步任务是否完成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> state = fut.<span class="built_in">valid</span>();</span><br></pre></td></tr></table></figure>

<p>可以调用 <code>valid()</code> 函数来检查 <code>std::future</code> 对象是否有效。如果 <code>std::future</code> 对象与异步操作相关联，并且异步操作尚未完成，则 <code>valid()</code> 函数返回 <code>true</code>，否则返回 <code>false</code>。</p>
<h2 id="3-异步执行策略"><a href="#3-异步执行策略" class="headerlink" title="3. 异步执行策略"></a>3. 异步执行策略</h2><p><code>std::async()</code> 函数提供的三种异步执行策略。它们决定了 <code>std::async()</code> 函数创建的异步任务的执行方式。</p>
<h3 id="1-std-launch-async"><a href="#1-std-launch-async" class="headerlink" title="1. std::launch::async"></a>1. std::launch::async</h3><ul>
<li><code>std::launch::async</code> 策略表示创建一个新的线程，在新的线程中异步执行指定的可调用对象。</li>
<li>这意味着异步任务会立即在一个新的线程中执行，不会阻塞当前线程。</li>
<li>使用 <code>std::launch::async</code> 策略创建的异步任务可以实现并行执行，适用于耗时的计算任务和I&#x2F;O操作等。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::future&lt;<span class="type">int</span>&gt; fut = std::<span class="built_in">async</span>(std::launch::async, task);</span><br></pre></td></tr></table></figure>

<h3 id="2-std-launch-deferred"><a href="#2-std-launch-deferred" class="headerlink" title="2. std::launch::deferred"></a>2. std::launch::deferred</h3><ul>
<li><code>std::launch::deferred</code> 策略表示延迟执行指定的可调用对象，直到调用 <code>get()</code> 函数时才在调用线程中执行。</li>
<li>这种策略不会创建新的线程，而是在需要时延迟执行。</li>
<li>使用 <code>std::launch::deferred</code> 策略创建的异步任务不会立即执行，直到调用 <code>get()</code> 函数时才执行，适用于延迟执行和惰性求值等场景。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::future&lt;<span class="type">int</span>&gt; fut = std::<span class="built_in">async</span>(std::launch::deferred, task);</span><br></pre></td></tr></table></figure>

<h3 id="3-std-launch-async-std-launch-deferred"><a href="#3-std-launch-async-std-launch-deferred" class="headerlink" title="3. std::launch::async | std::launch::deferred"></a>3. std::launch::async | std::launch::deferred</h3><ul>
<li><code>std::launch::async | std::launch::deferred</code> 表示由实现自行选择执行策略。</li>
<li>这种策略允许实现根据具体情况自行选择执行方式，可以在新的线程中异步执行，也可以在调用线程中延迟执行。</li>
<li>使用 <code>std::launch::async | std::launch::deferred</code> 策略创建的异步任务有可能在新的线程中执行，也有可能在调用线程中延迟执行，具体取决于实现。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::future&lt;<span class="type">int</span>&gt; fut = std::<span class="built_in">async</span>(std::launch::async | std::launch::deferred, task);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/08/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stars zhang">
      <meta itemprop="description" content="永远迎着光走">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/08/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">十大排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-08 12:00:05" itemprop="dateCreated datePublished" datetime="2024-04-08T12:00:05+08:00">2024-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-17 18:35:50" itemprop="dateModified" datetime="2024-04-17T18:35:50+08:00">2024-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-选择排序"><a href="#1-选择排序" class="headerlink" title="1. 选择排序"></a>1. 选择排序</h1><p>开启n-1轮循环，每次从未排序的元素中选择最小（或最大）的元素，将其与未排序序列的第一个元素交换位置，从而逐步构建有序序列。</p>
<p>选择排序的具体流程如下：</p>
<ol>
<li><strong>初始状态</strong>：将整个序列视为两部分，一部分是已排序序列，另一部分是未排序序列。</li>
<li><strong>选择最小元素</strong>：从未排序序列中选择最小的元素，并将其与未排序序列的第一个元素交换位置。</li>
<li><strong>扩大已排序序列</strong>：将交换后的元素视为已排序序列的一部分，未排序序列减少一个元素。</li>
<li><strong>重复步骤2和步骤3</strong>：直到所有元素都被选择并放置到正确的位置上。</li>
</ol>
<p>伪代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">选择排序(A):</span><br><span class="line">    <span class="keyword">for</span> i from <span class="number">0</span> <span class="function">to <span class="title">length</span><span class="params">(A)</span>-2:</span></span><br><span class="line"><span class="function">        minIndex =</span> i</span><br><span class="line">        <span class="keyword">for</span> j from i+<span class="number">1</span> <span class="function">to <span class="title">length</span><span class="params">(A)</span>-1:</span></span><br><span class="line"><span class="function">            if A[j] &lt; A[minIndex]:</span></span><br><span class="line"><span class="function">                minIndex =</span> j</span><br><span class="line">        <span class="comment">// 将未排序序列中最小元素与第i个元素交换位置</span></span><br><span class="line">        <span class="built_in">swap</span>(A[i], A[minIndex])</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n^2)</p>
<h1 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2. 冒泡排序"></a>2. 冒泡排序</h1><p>多次遍历待排序序列，每轮连续比较相邻的元素，如果“左元素 &gt; 右元素”则交换位置，使较大的元素逐步“冒泡”到数组的末端。</p>
<p>冒泡排序的具体流程如下：</p>
<ol>
<li><strong>比较相邻元素</strong>：从数组的第一个元素开始，比较相邻的两个元素，如果前一个元素比后一个元素大，则交换它们的位置，这样较大的元素就会向数组的末端移动。</li>
<li><strong>遍历整个数组</strong>：重复步骤1，遍历整个数组，直到所有的元素都已经比较过一次。</li>
<li><strong>缩小范围</strong>：每次遍历过程中，都会使得数组末端的一个元素排好序，因此<strong>在下一次遍历时，可以将待排序序列的范围缩小一个元素</strong>。</li>
</ol>
<p>伪代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">冒泡排序(A):</span><br><span class="line">    n = <span class="built_in">length</span>(A)</span><br><span class="line">    <span class="keyword">for</span> i from <span class="number">0</span> to n<span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">for</span> j from <span class="number">0</span> to n<span class="number">-1</span>-i:</span><br><span class="line">            <span class="keyword">if</span> A[j] &gt; A[j+<span class="number">1</span>]:</span><br><span class="line">                <span class="built_in">swap</span>(A[j], A[j+<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<h1 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h1><p>插入排序（Insertion Sort）是一种简单直观的排序算法。其基本思想是<strong>将待排序的数据序列分为已排序区间和未排序区间</strong>，通过构建有序序列，对未排序的数据逐个进行插入，从而达到排序的目的。</p>
<p>插入排序的具体思路如下：</p>
<ol>
<li><strong>初始状态</strong>：将第一个元素视为已排序序列，剩余的元素为未排序序列。</li>
<li><strong>遍历未排序序列</strong>：从第二个元素开始，逐个遍历未排序序列的元素。</li>
<li><strong>将当前元素插入已排序序列</strong>：对于每个未排序序列中的元素，将其与已排序序列中的元素逐个比较，找到合适的位置并插入。</li>
<li><strong>移动元素</strong>：为了给当前元素腾出位置，需要将已排序序列中比当前元素大的元素依次向后移动。</li>
<li><strong>重复步骤3和步骤4</strong>：直到所有元素都被插入到已排序序列中。</li>
</ol>
<p>伪代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">插入排序(A):</span><br><span class="line">    <span class="keyword">for</span> i from <span class="number">1</span> <span class="function">to <span class="title">length</span><span class="params">(A)</span>-1:</span></span><br><span class="line"><span class="function">        currentElement =</span> A[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> A[j] &gt; currentElement:</span><br><span class="line">            A[j+<span class="number">1</span>] = A[j]</span><br><span class="line">            j = j - <span class="number">1</span></span><br><span class="line">        A[j+<span class="number">1</span>] = currentElement</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<h1 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4. 快速排序"></a>4. 快速排序</h1><p>快速排序（quick sort）是一种基于<strong>分治</strong>策略的排序算法。基本思想是<strong>选择一个基准元素，将序列分割成两个子序列，其中一个子序列中的所有元素小于基准元素，另一个子序列中的所有元素大于基准元素，然后对这两个子序列分别进行递归排序。</strong></p>
<p>快速排序的具体步骤如下：</p>
<ol>
<li><strong>选择基准元素</strong>：从待排序序列中选择一个元素作为基准元素。通常选择序列的第一个元素、最后一个元素或者中间的元素作为基准元素。</li>
<li><strong>分割序列</strong>：根据基准元素，将序列分割成两个子序列，其中一个子序列中的元素小于基准元素，另一个子序列中的元素大于基准元素。通常使用两个指针（左指针和右指针）来实现分割，左指针指向序列的起始位置，右指针指向序列的末尾位置，然后从左右两端向中间移动指针，交换不符合条件的元素，直到左右指针相遇。</li>
<li><strong>递归排序</strong>：对两个子序列分别进行递归排序，直到子序列的长度为1或0。</li>
<li><strong>合并结果</strong>：将经过排序的子序列合并成最终的有序序列。</li>
</ol>
<p>伪代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">快速排序(A, low, high):</span><br><span class="line">    <span class="keyword">if</span> low &lt; high:</span><br><span class="line">        pivotIndex = partition(A, low, high)</span><br><span class="line">        快速排序(A, low, pivotIndex - <span class="number">1</span>)</span><br><span class="line">        快速排序(A, pivotIndex + <span class="number">1</span>, high)</span><br><span class="line"></span><br><span class="line">partition(A, low, high):</span><br><span class="line">    pivot = A[low]  // 选择第一个元素作为基准元素</span><br><span class="line">    left = low + <span class="number">1</span></span><br><span class="line">    right = high</span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> A[left] &lt;= pivot:</span><br><span class="line">            left = left + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> A[right] &gt; pivot:</span><br><span class="line">            right = right - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> left &lt; right:</span><br><span class="line">            swap(A[left], A[right])</span><br><span class="line">    swap(A[low], A[right])</span><br><span class="line">    <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure>

<p>快速排序的时间复杂度为 O(n log n)，其中 n 是待排序序列的长度。在平均情况下，快速排序的性能非常好，但是在最坏情况下（例如，当选择的基准元素总是序列中的最大或最小元素时），快速排序的时间复杂度可能会退化为 O(n^2)。</p>
<p>空间复杂度为O(n)：在输入数组完全倒序的情况下，达到最差递归深度 n ，使用 O(n)栈帧空间。若采用<strong>尾递归优化</strong>，则复杂度为O(log n)。</p>
<p>尾递归优化是一种编译器优化技术，用于优化递归调用的栈空间使用。在尾递归优化中，如果函数的最后一个操作是对自身的递归调用，编译器会将这种递归调用转换为循环，从而避免在调用栈上创建新的帧，节省了栈空间的使用。</p>
<h1 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h1><p>归并排序（Merge Sort）是一种基于<strong>分治</strong>思想的排序算法。其基本思路是将待排序序列<strong>分</strong>成两个子序列，分别对这两个子序列进行递归排序，然后将两个已经排好序的子序列<strong>合</strong>并成一个有序序列。</p>
<p>具体的算法流程：</p>
<ol>
<li><strong>分割序列：</strong>不断地将待排序序列划分成两个子序列，直到子序列的长度为1或0</li>
<li><strong>递归排序</strong>：递归地对分割后的两个子序列进行排序。</li>
<li><strong>合并序列：</strong>将两个已经排好序的子序列合并成一个有序序列。</li>
</ol>
<p>伪代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">归并排序(A):</span><br><span class="line">    <span class="keyword">if</span> length(A) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> A</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        middle = length(A) / <span class="number">2</span></span><br><span class="line">        left_half = 归并排序(A[<span class="number">0</span>:middle])  // 递归排序左半部分</span><br><span class="line">        right_half = 归并排序(A[middle:length(A)])  // 递归排序右半部分</span><br><span class="line">        <span class="keyword">return</span> 合并(left_half, right_half)  // 合并左右两部分并返回合并后的有序序列</span><br><span class="line"></span><br><span class="line">合并(left_half, right_half):</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> left_half 不为空 <span class="keyword">and</span> right_half 不为空:</span><br><span class="line">        <span class="keyword">if</span> left_half[<span class="number">0</span>] &lt;= right_half[<span class="number">0</span>]:</span><br><span class="line">            result.append(left_half[<span class="number">0</span>])</span><br><span class="line">            left_half = left_half[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right_half[<span class="number">0</span>])</span><br><span class="line">            right_half = right_half[<span class="number">1</span>:]</span><br><span class="line">    // 将剩余的元素追加到结果中</span><br><span class="line">    result += left_half</span><br><span class="line">    result += right_half</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>归并排序的时间复杂度为 O(n log n)。虽然归并排序的时间复杂度较低，但是需要额外的空间来存储归并过程中产生的临时序列，因此其空间复杂度为 O(n)。</p>
<h1 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6. 堆排序"></a>6. 堆排序</h1><p>堆排序（Heap Sort）是一种基于堆数据结构的排序算法，其基本思想是利用堆的性质实现排序。堆是一个特殊的树形数据结构，具有以下性质：</p>
<ol>
<li>它是一个完全二叉树，即除了最后一层，其他层都是满的。</li>
<li>在一个小顶堆（Min Heap）中，任意节点的值都小于或等于其子节点的值。</li>
<li>在一个大顶堆（Max Heap）中，任意节点的值都大于或等于其子节点的值。</li>
</ol>
<p>将待排序的序列构建成一个大顶堆，重复从堆中取出堆顶元素，并重新构建堆，直到堆为空，最终得到即为排序好的序列。</p>
<p>算法的流程：</p>
<ol>
<li><p>构建堆：</p>
<p>​		首先需要将待排序的序列构建成一个堆。一种常见的方法是从最后一个非叶子节点开始，依次向前进行调整，保证每个节点都满足堆的性质。</p>
<p>大顶堆的调整过程：</p>
<ul>
<li>从最后一个非叶子节点开始（即 n&#x2F;2-1），向前遍历到根节点。</li>
<li>对于每个节点，如果它的子节点中有比它大的，就将其与最大的子节点进行交换，直到它没有比它大的子节点或者到达叶子节点为止。</li>
</ul>
</li>
<li><p>排序：</p>
<p>​		构建好堆之后，需要重复从堆中取出最大（或最小）的元素，并重新调整堆，直到堆为空。具体的过程如下：</p>
<ul>
<li>将堆顶元素（最大或最小值）与堆中的最后一个元素交换位置。</li>
<li>从堆中移除最后一个元素（即最大或最小值）。</li>
<li>对剩余的元素重新调整堆，使其满足堆的性质。</li>
</ul>
<p>重复以上步骤，直到堆为空。</p>
</li>
</ol>
<h1 id="7-桶排序"><a href="#7-桶排序" class="headerlink" title="7. 桶排序"></a>7. 桶排序</h1><h1 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8. 计数排序"></a>8. 计数排序</h1><h1 id="9-基数排序"><a href="#9-基数排序" class="headerlink" title="9. 基数排序"></a>9. 基数排序</h1><h1 id="10-希尔排序"><a href="#10-希尔排序" class="headerlink" title="10. 希尔排序"></a>10. 希尔排序</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/08/%E6%90%9C%E7%B4%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stars zhang">
      <meta itemprop="description" content="永远迎着光走">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/08/%E6%90%9C%E7%B4%A2/" class="post-title-link" itemprop="url">搜索</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-08 10:36:42 / 修改时间：11:05:47" itemprop="dateCreated datePublished" datetime="2024-04-08T10:36:42+08:00">2024-04-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>搜索算法用于在数据结构（例如数组、链表、树或图）中搜索一个或一组满足特定条件的元素。</p>
<p>搜索算法可根据实现思路分为以下两类。</p>
<ul>
<li><strong>通过遍历数据结构来定位目标元素</strong>，例如数组、链表、树和图的遍历等。</li>
<li><strong>利用数据组织结构或数据包含的先验信息，实现高效元素查找</strong>，例如二分查找、哈希查找和二叉搜索树查找等。</li>
</ul>
<h1 id="1-暴力搜索"><a href="#1-暴力搜索" class="headerlink" title="1. 暴力搜索"></a>1. 暴力搜索</h1><p>暴力搜索通过遍历数据结构的每个元素来定位目标元素。</p>
<h2 id="1-线性搜索"><a href="#1-线性搜索" class="headerlink" title="1. 线性搜索"></a>1. 线性搜索</h2><ul>
<li>适用于<strong>数组</strong>和<strong>链表</strong>等线性数据结构。</li>
<li>顺序地逐个检查数据结构中的每个元素，直到找到目标元素或搜索完整个数据结构。</li>
<li>时间复杂度为**O(n)**，其中n是数据结构中的元素数量。</li>
</ul>
<h2 id="2-图搜索"><a href="#2-图搜索" class="headerlink" title="2. 图搜索"></a>2. 图搜索</h2><ul>
<li>用于在图&#x2F;树中查找特定的节点或路径，即<strong>深度优先搜索（Depth-First Search，DFS）</strong>和<strong>广度优先搜索（Breadth-First Search，BFS）</strong></li>
<li>广度优先搜索从初始节点开始逐层搜索，由近及远地访问各个节点。</li>
<li>深度优先搜索从初始节点开始，沿着一条路径走到头，再回溯并尝试其他路径，直到遍历完整个数据结构。</li>
<li>时间复杂度取决于图的结构和算法的实现方式。</li>
</ul>
<h1 id="2-自适应搜索"><a href="#2-自适应搜索" class="headerlink" title="2. 自适应搜索"></a>2. 自适应搜索</h1><p>自适应搜索利用数据的特有属性（例如有序性）来优化搜索过程，从而更高效地定位目标元素。</p>
<h2 id="1-二分搜索"><a href="#1-二分搜索" class="headerlink" title="1. 二分搜索"></a>1. 二分搜索</h2><ul>
<li>仅适用于已排序的数据结构（如有序数组），通过不断将搜索范围减半来定位目标元素。</li>
<li>时间复杂度为**O(log n)**。</li>
</ul>
<h2 id="2-哈希查找"><a href="#2-哈希查找" class="headerlink" title="2. 哈希查找"></a>2. <strong>哈希查找</strong></h2><ul>
<li>利用哈希表将<strong>搜索数据</strong>和<strong>目标数据</strong>建立为<strong>键值对映射</strong>，从而实现查询操作。</li>
<li>时间复杂度通常为**O(1)**，但在冲突较多的情况下可能会降低到O(n)。</li>
</ul>
<h2 id="3-树查找"><a href="#3-树查找" class="headerlink" title="3. 树查找"></a>3. 树查找</h2><ul>
<li>通过<strong>有序的树结构</strong>和特定的查找算法（如递归或迭代）来查找目标元素。</li>
<li>包括<strong>二叉搜索树（Binary Search Tree，BST）、平衡二叉树（Balanced Binary Tree，如AVL树、红黑树）、B树等</strong>。</li>
<li>平均情况下的时间复杂度取决于树的高度，**通常为O(log n)**，但在最坏情况下可能为O(n)。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/07/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stars zhang">
      <meta itemprop="description" content="永远迎着光走">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/07/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/" class="post-title-link" itemprop="url">浅拷贝与深拷贝</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-07 13:04:49 / 修改时间：13:59:15" itemprop="dateCreated datePublished" datetime="2024-04-07T13:04:49+08:00">2024-04-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><ul>
<li>简单的拷贝对象成员变量的值，而不拷贝对象所指向的动态分配的内存。</li>
<li>因此，新旧对象的指针成员指向相同内存地址的指针，它们将共享同一块内存，可能导致潜在的问题。</li>
<li>如果其中一个对象销毁了这个指针指向的内存，另一个对象可能会引用已经无效的内存地址。</li>
<li>当一个对象发生改变时，由于另一个对象与之共享同一块内存，另一个对象也会受到影响。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShallowCopy</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ShallowCopy</span>(<span class="type">int</span> val) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="built_in">int</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ShallowCopy</span>(<span class="type">const</span> ShallowCopy &amp;other) &#123;</span><br><span class="line">        data = other.data; <span class="comment">// 进行浅拷贝</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;shallow copy&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getData</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setData</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        *data = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ShallowCopy</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ShallowCopy <span class="title">a1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    ShallowCopy a2 = a1;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1=&quot;</span> &lt;&lt; a1.<span class="built_in">getData</span>() &lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;a2=&quot;</span> &lt;&lt; a2.<span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    a1.<span class="built_in">setData</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1=&quot;</span> &lt;&lt; a1.<span class="built_in">getData</span>() &lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;a2=&quot;</span> &lt;&lt; a2.<span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shallow copy</span><br><span class="line">a1=<span class="number">5</span> a2=<span class="number">5</span></span><br><span class="line">a1=<span class="number">10</span> a2=<span class="number">10</span></span><br></pre></td></tr></table></figure>

<h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><ul>
<li>不仅拷贝对象本身，还拷贝对象所指向的动态分配的内存，以确保拷贝后的对象和原对象指向的内存是独立的。</li>
<li>深拷贝会为新的对象分配一块新的内存，并将原对象所指向的内存的内容复制到新分配的内存中，从而使得新旧对象完全独立，互不影响。</li>
<li>即使两个对象有相同的值，它们也各自拥有一份独立的内存副本，彼此互不影响。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeepCopy</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DeepCopy</span>(<span class="type">int</span> val) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="built_in">int</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DeepCopy</span>(<span class="type">const</span> DeepCopy &amp;other) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">        *data = *(other.data); <span class="comment">// 进行深拷贝</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;deep copy&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getData</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setData</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        *data = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">DeepCopy</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">DeepCopy <span class="title">b1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">DeepCopy <span class="title">b2</span><span class="params">(b1)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b1=&quot;</span> &lt;&lt; b1.<span class="built_in">getData</span>() &lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;b2=&quot;</span> &lt;&lt; b2.<span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    b1.<span class="built_in">setData</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b1=&quot;</span> &lt;&lt; b1.<span class="built_in">getData</span>() &lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;b2=&quot;</span> &lt;&lt; b2.<span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deep copy</span><br><span class="line">b1=<span class="number">5</span> b2=<span class="number">5</span></span><br><span class="line">b1=<span class="number">10</span> b2=<span class="number">5</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/07/%E5%B7%A6%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stars zhang">
      <meta itemprop="description" content="永远迎着光走">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/07/%E5%B7%A6%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/" class="post-title-link" itemprop="url">左右值引用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-07 12:32:40" itemprop="dateCreated datePublished" datetime="2024-04-07T12:32:40+08:00">2024-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-10 10:13:53" itemprop="dateModified" datetime="2024-04-10T10:13:53+08:00">2024-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-左值、右值"><a href="#1-左值、右值" class="headerlink" title="1. 左值、右值"></a>1. 左值、右值</h1><h2 id="左值："><a href="#左值：" class="headerlink" title="左值："></a>左值：</h2><ul>
<li>表达式结束后依然存在的<strong>持久性对象</strong>或者函数，可以被取地址。</li>
<li>左值是可以被标识符引用的表达式，它们代表着内存中的一个位置。例如，变量、数组元素、通过引用或指针访问的对象、具有名称的对象等都是左值。</li>
<li>左值在赋值操作符左侧出现，可以接受赋值操作。</li>
</ul>
<h2 id="右值："><a href="#右值：" class="headerlink" title="右值："></a>右值：</h2><ul>
<li>表达式结束后就消失的<strong>临时对象</strong>，通常不能被取地址。</li>
<li>右值是不具有持久性的临时对象或者表达式的结果，不能被直接引用。例如，字面常量、临时对象、未命名的临时对象、返回临时对象的函数调用等都是右值。</li>
<li>右值通常出现在赋值操作符右侧，用于提供值给赋值操作。</li>
</ul>
<h1 id="2-左值引用、右值引用"><a href="#2-左值引用、右值引用" class="headerlink" title="2. 左值引用、右值引用"></a>2. 左值引用、右值引用</h1><h2 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h2><ul>
<li>左值引用是通过使用 <code>&amp;</code> 符号声明的引用类型。它绑定到左值，并且可以延长左值的生命周期，使得左值可以在函数调用等情况下被修改。</li>
<li>左值引用不能绑定到右值。</li>
<li>左值引用常用于函数参数传递、函数返回值和操作符重载等场景，可以实现有效的引用语义和避免不必要的拷贝。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a; <span class="comment">// b是左值引用</span></span><br><span class="line">b = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> &amp;c = <span class="number">10</span>; <span class="comment">// error，10无法取地址，无法进行引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;d = <span class="number">10</span>; <span class="comment">// ok，因为是常引用，引用常量数字，这个常量数字会存储在内存中，可以取地址</span></span><br></pre></td></tr></table></figure>

<p>可以得出结论：对于左值引用，等号右边的值必须可以取地址，如果不能取地址，则会编译失败，或者可以使用const引用形式，但这样就只能通过引用来读取输出，不能修改数组，因为是常量引用。</p>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><ul>
<li>右值引用是通过使用 <code>&amp;&amp;</code> 符号声明的引用类型。它主要用于绑定到临时对象或者即将销毁的对象，允许移动语义的使用。</li>
<li>右值引用可以绑定到右值，但不能绑定到左值。</li>
<li>右值引用的引入使得可以实现移动语义，即将资源从一个对象“移动”到另一个对象，而不是进行昂贵的拷贝操作。这在处理临时对象时尤为有用，能够提高性能。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;&#125; <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; other) &#123;&#125; <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp; other) &#123;&#125; <span class="comment">// 移动构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">createA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">A</span>(); <span class="comment">// 返回一个临时对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a1 = <span class="built_in">createA</span>(); <span class="comment">// 调用移动构造函数，避免了拷贝</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>std::move函数：把一个左值强制转换成一个右值 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> &amp;&amp;b = a; <span class="comment">// error, a是左值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;c = std::<span class="built_in">move</span>(a); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<h1 id="3-移动语义"><a href="#3-移动语义" class="headerlink" title="3. 移动语义"></a>3. 移动语义</h1><ul>
<li>利用右值引用允许在对象间转移资源的所有权，而不是传统的拷贝。</li>
<li>这种转移资源的操作比拷贝操作更高效，特别是对于动态分配的内存或者其他资源。</li>
<li>移动语义的引入是为了解决传统的拷贝操作在处理临时对象时可能造成性能开销的问题。</li>
<li>移动语义的核心概念在于，当一个对象被标记为将要被销毁（右值），它的资源可以被安全地“窃取”到另一个对象，而不是简单地复制。这意味着移动操作将对象的资源所有权从一个对象转移到另一个对象，而不会发生资源的复制或者额外的分配。</li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol>
<li>避免不必要的拷贝操作</li>
<li>实现资源管理的高效转移</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Resource</span>() &#123;&#125;</span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">Resource</span>(Resource&amp;&amp; other) &#123;</span><br><span class="line">        <span class="comment">// 窃取资源</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;data = other.data;</span><br><span class="line">        other.data = <span class="literal">nullptr</span>; <span class="comment">// 将原始对象置为空，避免资源重复释放</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Resource res1;</span><br><span class="line">    Resource res2 = std::<span class="built_in">move</span>(res1); <span class="comment">// 调用移动构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-完美转发"><a href="#4-完美转发" class="headerlink" title="4. 完美转发"></a>4. 完美转发</h1><ul>
<li>允许将参数传递到另一个函数，并保留原始参数的值类别（左值或右值）和const修饰符。</li>
<li>目标是在保留参数类型的同时，将参数转发给其他函数，实现通用性更强的函数包装或者委托。</li>
<li>完美转发的关键是使用了<strong>右值引用</strong>和<strong>模板参数</strong>推导。通过使用 <code>std::forward</code> 函数模板，可以在传递参数时保留参数的值类别，确保参数被按原样传递。这种机制在实现泛型编程时尤为有用，可以减少代码的重复和增加可读性。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// arg 是右值引用或者左值引用，依据传递的实参类型决定</span></span><br><span class="line">    <span class="comment">// 将参数 arg 转发给另一个函数 foo()</span></span><br><span class="line">    <span class="built_in">foo</span>(std::forward&lt;T&gt;(arg)); <span class="comment">// 完美转发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123; </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;left value&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123; </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;right value&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">wrapper</span>(x); <span class="comment">// 传递左值</span></span><br><span class="line">    <span class="built_in">wrapper</span>(<span class="number">42</span>); <span class="comment">// 传递右值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>wrapper</code> 函数模板通过 <code>std::forward</code> 将参数 <code>arg</code> 完美转发给 <code>foo</code> 函数。无论 <code>arg</code> 是左值还是右值，都可以在 <code>foo</code> 中保持其原始的属性，并且正确地调用对应的 <code>foo</code> 函数重载。</p>
<p>运行结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">42</span>: left value</span><br><span class="line"><span class="number">42</span>: right value</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/05/%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stars zhang">
      <meta itemprop="description" content="永远迎着光走">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/05/%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">指针和引用的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-05 18:15:10" itemprop="dateCreated datePublished" datetime="2024-04-05T18:15:10+08:00">2024-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-04 16:24:49" itemprop="dateModified" datetime="2024-05-04T16:24:49+08:00">2024-05-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="一、区别"><a href="#一、区别" class="headerlink" title="一、区别"></a>一、区别</h4><h5 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h5><p>（1）指针是一个变量，其值为另一个变量的地址，指向内存的一个存储单元。是一个对象实体</p>
<p>（2）而引用的本质是给变量起别名，允许通过这个别名去直接操纵和修改对象本身的属性。引用跟原来的变量实质上是同一个东西。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//指针</span></span><br><span class="line"><span class="type">int</span>* p = &amp;a;</span><br><span class="line"><span class="comment">//引用</span></span><br><span class="line"><span class="type">int</span>&amp; b = a;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-空指针与无效引用"><a href="#1-2-空指针与无效引用" class="headerlink" title="1.2 空指针与无效引用"></a>1.2 空指针与无效引用</h5><p>（1）指针可以为空，表示它不指向任何有效的内存地址。在指针没有被初始化时，它的值通常是未定义的，为了避免错误，可以将其初始化为 <code>nullptr</code> 或 <code>NULL</code>。</p>
<p>（2）引用不能为空，它必须在声明时被初始化，并且始终指向某个对象。试图将引用声明为 null 或者空值会导致编译错误。</p>
<h5 id="1-3-初始化"><a href="#1-3-初始化" class="headerlink" title="1.3 初始化"></a>1.3 初始化</h5><p>（1）指针需要进行初始化，可以使用取地址符号 <code>&amp;</code> 来获取一个变量的地址，也可以将另一个指针赋值给它。</p>
<p>（2）引用在声明时必须初始化，而且一旦初始化后，不能被重新绑定到其他变量。</p>
<ol start="4">
<li>运算符</li>
</ol>
<p>（1）指针可以通过解引用 <code>*</code> 运算符来访问所指向的对象，也可以使用箭头 <code>-&gt;</code> 运算符来访问成员，例如：<code>p-&gt;member</code>。</p>
<p>（2）引用则不需要解引用操作符，因为它们在使用时就是被解引用的。例如：<code>b.member</code>。</p>
<h4 id="二、指针常量、常量指针、引用"><a href="#二、指针常量、常量指针、引用" class="headerlink" title="二、指针常量、常量指针、引用"></a>二、指针常量、常量指针、引用</h4><ol>
<li>指针常量：如int* const p，表示一个指向整数类型的指针常量。</li>
</ol>
<ul>
<li><code>int*</code>：表示指向整数类型的指针。这意味着 <code>p</code> 是一个指针，可以存储整数类型变量的地址。</li>
<li><code>const</code>：表示常量，这里用于修饰指针。<code>const</code> 关键字使得指针变量成为一个常量，即<strong>指针的值（地址）不能被修改，但是可以通过 <code>p</code> 修改它所指向的整数值。</strong></li>
</ul>
<ol start="2">
<li>常量指针：如const int* p，表示一个指向整数常量的指针。</li>
</ol>
<ul>
<li><code>const</code>：表示常量，这里用于修饰整数类型。<code>const</code> 关键字使得指针所指向的整数值为常量，即<strong>不能通过 <code>p</code> 修改它所指向的整数值。</strong></li>
<li><code>int*</code>：表示指向整数类型的指针。这意味着 <code>p</code> 是一个指针，可以更改指针的指向，让其指向其他值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int x = 10;</span><br><span class="line">int y = 20;</span><br><span class="line"></span><br><span class="line">int* const p1 = &amp;x;  // p 是一个指向整数类型的指针常量，指向 x 的地址</span><br><span class="line">*p1 = 15;            // 合法，修改了 p 指向的整数变量 x 的值</span><br><span class="line">// p1 = &amp;y;         // 不合法，试图修改 p 的值（地址），但 p 是一个常量，其值不能修改</span><br><span class="line"></span><br><span class="line">const int z = 20;</span><br><span class="line">const int* p2 = &amp;x;  // p 是一个指向常量整数类型的指针，指向 x 的地址</span><br><span class="line">// *p2 = 15;         // 不合法，试图通过 p 修改其所指向的整数值，但整数值是常量，不能修改</span><br><span class="line">p2 = &amp;z;             // 合法，修改 p 指向的地址，但是 p 仍然指向一个整数类型的常量</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>引用的本质在c++内部实现是一个指针常量.</strong> 即可以通过引用修改原变量值，但引用不能更改绑定其他变量。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; b = a;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> b = &amp;a;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/27/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stars zhang">
      <meta itemprop="description" content="永远迎着光走">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/27/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/" class="post-title-link" itemprop="url">线程同步</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-27 13:12:33" itemprop="dateCreated datePublished" datetime="2024-03-27T13:12:33+08:00">2024-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-08 13:25:01" itemprop="dateModified" datetime="2024-04-08T13:25:01+08:00">2024-04-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>进程有自己的独立地址空间，因此<strong>进程之间重点关注通信</strong>。而对于线程来说，除了线程栈外其他数据都是共享的，如果同时读写数据可能造成数据不一致甚至程序崩溃的后果，因此<strong>线程之间重点关注同步</strong>。</p>
<p>线程同步是指在多线程编程中控制多个线程之间的执行顺序或共享资源访问的过程。在多线程环境中，由于线程的并发执行，可能会导致数据竞争、资源冲突等问题。</p>
<h1 id="1-竞争条件"><a href="#1-竞争条件" class="headerlink" title="1. 竞争条件"></a>1. 竞争条件</h1><p>在多线程编程中，<strong>竞争</strong>（Race condition）是指两个或多个线程对共享资源的访问产生的不确定性行为。竞争条件通常发生在多个线程同时访问共享资源时，其中至少一个线程试图修改这些资源的值。在多线程并发场景下指令执行的先后顺序由内核决定，同一个线程内部指令按照先后顺序执行，但不同线程之间的指令执行先后顺序是不一定的。如果执行结果依赖于不同线程执行的先后顺序，那么就会形成<strong>“竞争条件”</strong>，产生非预期的计算结果，导致程序崩溃等问题。</p>
<p>最常见的解决竞争条件的方式是<strong>原子操作</strong>，其次便是<strong>线程同步</strong>。</p>
<p>原子操作是指不可被中断的操作，在执行过程中不会被其他线程或进程干扰，要么全部执行成功，要么全部不执行，不会出现部分执行的情况。原子操作通常是基本的、不可分割的操作单元。</p>
<p>原子操作通常由硬件或者操作系统提供支持，C++11引入了std::atomic模板类来支持原子操作。</p>
<h1 id="2-线程同步"><a href="#2-线程同步" class="headerlink" title="2. 线程同步"></a>2. 线程同步</h1><p>常见的线程同步的方式有四种：互斥锁、读写锁、条件变量和信号量</p>
<h2 id="2-1-互斥锁"><a href="#2-1-互斥锁" class="headerlink" title="2.1 互斥锁"></a>2.1 互斥锁</h2><p>互斥锁（又名互斥量）强调的是资源之间的访问互斥：每个线程在对共享资源操作前都会尝试先加锁，加锁成功才能操作，操作结束之后解锁。</p>
<p>某个线程对互斥量加锁后，其他线程必须等待该线程释放锁才能继续访问共享资源。如果释放互斥锁时有多个线程阻塞，所有在该互斥锁上的阻塞线程都会变成可运行状态。第一个变成运行状态的线程可以对互斥量加锁，其余线程将会看到互斥量依然被锁住，只能回去再次等待它重新变为可用。</p>
<p>mutex是睡眠等待（sleep waiting）类型的锁，<strong>当线程抢互斥锁失败的时候，线程会陷入休眠</strong>。优点就是节省CPU资源，缺点就是休眠唤醒会消耗一点时间。</p>
<p>互斥锁的接口通常包括 <code>mutex_init()</code>、<code>mutex_lock()</code>、<code>mutex_unlock()</code> 和 <code>mutex_destroy()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化互斥锁</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁互斥锁</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2-2-读写锁"><a href="#2-2-读写锁" class="headerlink" title="2.2 读写锁"></a>2.2 读写锁</h2><p>读写锁和互斥量类似，是另一种实现线程同步的方式，但是它将操作分为读、写两种方式，可以多个线程同时占用读模式，但只允许一个线程写入。</p>
<ul>
<li>写独占：写锁占用时，其他线程加读锁或者写锁时都会阻塞（并非失败）</li>
<li>读共享：读锁占用时，其他线程加写锁时会阻塞，加读锁会成功</li>
</ul>
<p>读写锁有两种策略：</p>
<ul>
<li>强读同步：读锁优先，只要写锁没有占用那么就可以加读锁</li>
<li>强写同步：写锁优先，只能等到所有正在等待或者执行的写锁执行完成后才能加读锁</li>
</ul>
<p>大部分读写锁的实现都采用的是“强写同步”策略，对尝试加锁的操作进行排队，如果前面已经有尝试加写被锁阻塞住的话，后续加读锁也都会被阻塞住（尽管当前时刻是读锁占用的状态）。这样做的目的主要是为了避免“写饥饿”，在“多读少写”的情况下防止数据修改延迟过高。</p>
<p>读写锁的接口通常包括 <code>rwlock_init()</code>、<code>rwlock_rdlock()</code>、<code>rwlock_wrlock()</code>、<code>rwlock_unlock()</code> 和 <code>rwlock_destroy()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化读写锁</span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line">pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取加锁</span></span><br><span class="line">pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入加锁</span></span><br><span class="line">pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁读写锁</span></span><br><span class="line">pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-3-条件变量"><a href="#2-3-条件变量" class="headerlink" title="2.3 条件变量"></a>2.3 条件变量</h2><p>严格意义上来说，条件变量的主要作用不是处理线程同步, 而是进行线程的阻塞。如果在多线程程序中只使用条件变量无法实现线程的同步, 必须要配合互斥锁来使用。</p>
<p>线程可以等待某个条件变量的发生，如果条件不满足，则线程会阻塞等待，并在条件满足时被唤醒。</p>
<p>条件变量的接口通常包括 <code>cond_init()</code>、<code>cond_wait()</code>、<code>cond_signal()</code> 和 <code>cond_broadcast()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化条件变量和关联的互斥锁</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待条件满足</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送信号通知条件满足</span></span><br><span class="line">pthread_cond_signal(&amp;cond);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广播通知条件满足</span></span><br><span class="line">pthread_cond_broadcast(&amp;cond);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-4-信号量"><a href="#2-4-信号量" class="headerlink" title="2.4 信号量"></a>2.4 信号量</h2><p>信号量是一种更为通用的同步原语，用来控制多个线程对共享资源的访问。</p>
<p>信号量本质上是一个非负的整数计数器，表示可用资源的数量。当资源被占用时，计数器减少；当资源释放时，计数器增加。</p>
<p>信号量提供了两种操作：P操作（等待信号量）和V操作（释放信号量），用于控制资源的访问和释放，也被称为PV原子操作：</p>
<ul>
<li>P操作：即信号量sem减一，若sem小于等于0则P操作被阻塞，直到sem变量大于0为止</li>
<li>V操作：即信号量sem加一</li>
</ul>
<p>信号量的接口通常包括 <code>sem_init()</code>、<code>sem_wait()</code>、<code>sem_post()</code> 和 <code>sem_destroy()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="type">sem_t</span> semaphore;</span><br><span class="line">sem_init(&amp;semaphore, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 初始值为1，表示有一个资源可用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待信号量</span></span><br><span class="line">sem_wait(&amp;semaphore);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送信号量</span></span><br><span class="line">sem_post(&amp;semaphore);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁信号量</span></span><br><span class="line">sem_destroy(&amp;semaphore);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="3-C-示例"><a href="#3-C-示例" class="headerlink" title="3. C++示例"></a>3. C++示例</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">// 用于 sleep 函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享资源</span></span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁</span></span><br><span class="line">mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读写锁</span></span><br><span class="line">shared_mutex rw_mtx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件变量</span></span><br><span class="line">condition_variable cond_var;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量</span></span><br><span class="line"><span class="type">sem_t</span> semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mutex_example</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is accessing shared resource with mutex. Shared data: &quot;</span> &lt;&lt; shared_data &lt;&lt; endl;</span><br><span class="line">    shared_data++;</span><br><span class="line">    mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读写锁示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rw_lock_example</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 读操作</span></span><br><span class="line">        <span class="function">shared_lock&lt;shared_mutex&gt; <span class="title">lock</span><span class="params">(rw_mtx)</span></span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is reading shared resource with read-write lock. Shared data: &quot;</span> &lt;&lt; shared_data &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 写操作</span></span><br><span class="line">        unique_lock&lt;shared_mutex&gt; <span class="built_in">lock</span>(rw_mtx);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is writing shared resource with read-write lock. Shared data: &quot;</span> &lt;&lt; shared_data &lt;&lt; endl;</span><br><span class="line">        shared_data++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件变量示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cond_var_example</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    cond_var.<span class="built_in">wait</span>(lock, []&#123; <span class="keyword">return</span> ready; &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is accessing shared resource with condition variable. Shared data: &quot;</span> &lt;&lt; shared_data &lt;&lt; endl;</span><br><span class="line">    shared_data++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">semaphore_example</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;semaphore);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is accessing shared resource with semaphore. Shared data: &quot;</span> &lt;&lt; shared_data &lt;&lt; endl;</span><br><span class="line">    shared_data++;</span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;semaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;semaphore, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(mutex_example, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(mutex_example, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(rw_lock_example, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t4</span><span class="params">(rw_lock_example, <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t5</span><span class="params">(cond_var_example, <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t6</span><span class="params">(cond_var_example, <span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t7</span><span class="params">(semaphore_example, <span class="number">7</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t8</span><span class="params">(semaphore_example, <span class="number">8</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知条件变量</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cond_var.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    t4.<span class="built_in">join</span>();</span><br><span class="line">    t5.<span class="built_in">join</span>();</span><br><span class="line">    t6.<span class="built_in">join</span>();</span><br><span class="line">    t7.<span class="built_in">join</span>();</span><br><span class="line">    t8.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;semaphore);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4. 死锁"></a>4. 死锁</h1><p>死锁（Deadlock）是指两个或多个进程(线程)在互相等待对方持有的资源而无法继续执行的情况。在死锁状态下，每个进程都在等待某个资源被释放，而该资源被其他进程所持有，导致所有进程都无法继续执行。</p>
<p>死锁发生的<strong>主要原因</strong>通常是由于多个进程同时持有某些资源，并且每个进程都在等待其他进程释放它所需要的资源。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stars zhang">
      <meta itemprop="description" content="永远迎着光走">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">C++并发与多线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-26 19:37:30" itemprop="dateCreated datePublished" datetime="2024-03-26T19:37:30+08:00">2024-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-05 10:15:47" itemprop="dateModified" datetime="2024-04-05T10:15:47+08:00">2024-04-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一个程序只有一个进程，但可以拥有至少一个线程（主线程），这些线程共同拥有进程的地址空间。</p>
<p>C++11通过std::thread进行多线程编程</p>
<h1 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1. 构造函数"></a>1. 构造函数</h1><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">类别</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">thread() noexcept</td>
<td align="center">默认构造函数</td>
<td align="center">创建一个线程，但什么也不做</td>
</tr>
<tr>
<td align="center">template&lt; class Function, class… Args &gt;<br>explicit thread( Function&amp;&amp; f, Args&amp;&amp;… args )</td>
<td align="center">初始化构造函数</td>
<td align="center">创建一个线程，以<code>args</code>为参数执行<code>fn</code>函数</td>
</tr>
<tr>
<td align="center">thread( thread&amp;&amp; other ) noexcept</td>
<td align="center">移动构造函数</td>
<td align="center">将 other 的线程所有权转移给新的thread 对象</td>
</tr>
<tr>
<td align="center">thread( const thread&amp; ) &#x3D; delete</td>
<td align="center">复制构造函数</td>
<td align="center">使用&#x3D;delete显示删除拷贝构造, 不允许线程对象之间的拷贝</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/25/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stars zhang">
      <meta itemprop="description" content="永远迎着光走">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/25/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" class="post-title-link" itemprop="url">IO多路复用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-25 10:00:09" itemprop="dateCreated datePublished" datetime="2024-03-25T10:00:09+08:00">2024-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-16 14:35:27" itemprop="dateModified" datetime="2024-04-16T14:35:27+08:00">2024-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>应用通常需要在多个文件描述符上阻塞：在键盘输入（stdin）、进程间通信以及很多文件之间协调I&#x2F;O 。</p>
<p>在传统的IO模型中，每个IO操作都需要创建一个新的线程或进程来处理。因为单个进程无法同时在多个文件描述符上阻塞。 </p>
<p>I&#x2F;O多路复用支持<strong>一个线程同时监测多个文件描述符并且这个过程是阻塞的，当有IO操作可以进行时才唤醒线程进行处理，避免了频繁的线程创建和切换</strong>，提高了系统的效率。 </p>
<p>多线程&#x2F;多进程并发和IO多路复用的并发处理流程进行对比（服务器端）：</p>
<ul>
<li><p>多线程&#x2F;多进程并发</p>
<ul>
<li>主线程&#x2F;父进程：调用 accept()监测客户端连接请求，如果没有新的客户端的连接请求，当前线程&#x2F;进程会阻塞；如果有新的客户端连接请求解除阻塞，建立连接</li>
<li>子线程&#x2F;子进程：和建立连接的客户端通信。<ul>
<li>调用 read() &#x2F; recv() 接收客户端发送的通信数据，如果没有通信数据，当前线程&#x2F;进程会阻塞，数据到达之后阻塞自动解除</li>
<li>调用 write() &#x2F; send() 给客户端发送数据，如果写缓冲区已满，当前线程&#x2F;进程会阻塞，否则将待发送数据写入写缓冲区中</li>
</ul>
</li>
</ul>
</li>
<li><p>IO多路复用并发</p>
<ul>
<li><p>使用IO多路复用函数委托<strong>内核</strong>检测服务器端所有的文件描述符（通信和监听两类），检测过程会导致进程&#x2F;线程的阻塞，如果检测到已就绪的文件描述符阻塞解除，并将这些已就绪的文件描述符传出</p>
</li>
<li><p>根据类型对传出的所有已就绪文件描述符进行判断，并做出不同的处理</p>
<ul>
<li><p>监听的文件描述符：和客户端建立连接，此时调用accept()不会导致程序阻塞，因为监听的文件描述符是已就绪的（有新请求）</p>
</li>
<li><p>通信的文件描述符：调用通信函数和已建立连接的客户端通信，调用 read() &#x2F; recv() 不会阻塞程序，因为通信的文件描述符是就绪的，读缓冲区内已有数据；调用 write() &#x2F; send() 不会阻塞程序，因为通信的文件描述符是就绪的，写缓冲区不满，可以往里面写数据</p>
</li>
</ul>
</li>
<li><p>对这些文件描述符继续进行下一轮的检测</p>
</li>
</ul>
</li>
</ul>
<p>Linux提供了三种I&#x2F;O多路复用方案：select、poll和epoll </p>
<h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>nfds</code>：待检测的文件描述符的数量，即监视的文件描述符集合中<strong>最大的文件描述符加1</strong>。</li>
<li><code>readfds</code>：指向一个集合，包含了希望监视其读操作的文件描述符。</li>
<li><code>writefds</code>：指向一个集合，包含了希望监视其写操作的文件描述符。</li>
<li><code>exceptfds</code>：指向一个集合，包含了希望监视错误异常的文件描述符。</li>
<li><code>timeout</code>：指定超时时间，即 select() 函数最多等待的时间。如果设置为 NULL，则表示一直等待，直到有事件发生；如果设置为 0，则表示立即返回。</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>大于0：成功，返回集合中已就绪的IO总个数</li>
<li>等于-1：调用失败</li>
<li>等于0：没有就绪的IO</li>
</ul>
<p>fd_set本质是一个数组，为了方便我们操作该数组，操作系统提供了以下函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/ 将文件描述符fd从<span class="built_in">set</span>集合中删除 </span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断文件描述符fd是否在set集合中 </span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文件描述符fd添加到set集合中 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 将set集合中, 所有文件描述符对应的标志位设置为0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>select() 函数的<strong>基本工作原理</strong>：</p>
<ol>
<li>当用户process调用select的时候，select会将需要监控的readfds集合拷贝到内核空间（假设监控的仅仅是socket可读），</li>
<li>然后遍历自己监控的skb(SocketBuffer)，挨个调用skb的poll逻辑以便检查该socket是否有可读事件，</li>
<li>遍历完所有的skb后，如果没有任何一个socket可读，那么select会调用schedule_timeout进入schedule循环，使得process进入睡眠。</li>
<li>如果在timeout时间内某个socket上有数据可读了，或者等待timeout了，则调用select的process会被唤醒，接下来select就是遍历监控的集合，挨个收集可读事件并返回给用户了</li>
</ol>
<p>需要注意的是，select() 函数有一些局限性，其中最主要的是：</p>
<ul>
<li><code>nfds</code> 参数需要指定为待监视文件描述符的最大值加1，这意味着它的性能可能受到文件描述符数量的限制。</li>
<li>select() 的效率可能会随着待监视的文件描述符数量的增加而下降。</li>
<li>select() 函数的时间复杂度为 O(n)，因此在大规模文件描述符的情况下可能效率较低。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    fd_set readfds;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">    <span class="type">int</span> fds[NUM_FDS] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 存储文件描述符</span></span><br><span class="line">    <span class="type">int</span> maxfd = <span class="number">0</span>; <span class="comment">// 最大文件描述符</span></span><br><span class="line">    <span class="type">int</span> retval, i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个文件描述符（示例中使用stdin和stdout）</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        fds[i] = i &lt; <span class="number">3</span> ? STDIN_FILENO : STDOUT_FILENO; <span class="comment">// 前三个是 stdin，后两个是 stdout</span></span><br><span class="line">        <span class="keyword">if</span> (fds[i] &gt; maxfd) &#123;</span><br><span class="line">            maxfd = fds[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空文件描述符集合</span></span><br><span class="line">    FD_ZERO(&amp;readfds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有文件描述符加入读集合</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        FD_SET(fds[i], &amp;readfds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置超时时间为5秒</span></span><br><span class="line">    timeout.tv_sec = <span class="number">5</span>;</span><br><span class="line">    timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用select()函数进行监听</span></span><br><span class="line">    retval = select(maxfd + <span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (retval == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;select()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No data within 5 seconds.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 检查就绪的文件描述符</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(fds[i], &amp;readfds)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Data is available from fd %d.\n&quot;</span>, fds[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h1><p>poll的实现和select非常相似，只是描述fd集合的方式不同。poll使用pollfd结构而不是select的fd_set结构，这就解决了select中fds集合大小1024限制问题。但poll和select同样存在一个性能缺点就是包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd;         <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">short</span> events;   <span class="comment">// 要监视的事件（可通过常量定义）</span></span><br><span class="line">    <span class="type">short</span> revents;  <span class="comment">// 监视的事件中满足条件返回的事件（由内核填充）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>fds</code>：一个指向 <code>struct pollfd</code> 结构体数组的指针，其中每个元素描述了一个要监视的文件描述符及其所关注的事件。struct pollfd有三个成员：<ul>
<li><code>fd</code>：委托内核检测的文件描述符</li>
<li><code>events</code>：委托内核检测的fd事件（输入、输出、错误），它可以是以下几种事件的组合：<ul>
<li><code>POLLIN</code>：文件描述符可读。</li>
<li><code>POLLOUT</code>：文件描述符可写。</li>
<li><code>POLLERR</code>：发生错误。</li>
<li><code>POLLHUP</code>：对端挂起。</li>
</ul>
</li>
<li><code>revents</code>：这是一个传出参数，数据由内核写入，存储内核检测之后的结果</li>
</ul>
</li>
<li><code>nfds</code>：要监视的文件描述符的数量，类型实际是unsigned long</li>
<li><code>timeout</code>：指定超时时间，单位是毫秒。如果设置为负值，<code>poll()</code> 将会无限期等待，直到有事件发生；如果设置为 0，则 <code>poll()</code> 将立即返回，不管是否有事件发生。</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>-1：失败</li>
<li>大于0：表示检测的集合中已就绪的文件描述符的总个数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_FDS 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[<span class="title">NUM_FDS</span>];</span></span><br><span class="line">    <span class="type">int</span> timeout = <span class="number">5000</span>; <span class="comment">// 5秒超时</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个文件描述符（示例中使用 stdin 和 stdout）</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUM_FDS; ++i) &#123;</span><br><span class="line">        fds[i].fd = i &lt; <span class="number">3</span> ? STDIN_FILENO : STDOUT_FILENO; <span class="comment">// 前三个是 stdin，后两个是 stdout</span></span><br><span class="line">        fds[i].events = i &lt; <span class="number">3</span> ? POLLIN : POLLOUT; <span class="comment">// 前三个监视读事件，后两个监视写事件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 poll() 函数进行监听</span></span><br><span class="line">    <span class="type">int</span> retval = poll(fds, NUM_FDS, timeout);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (retval == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;poll()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No data within 5 seconds.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 检查就绪的文件描述符</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUM_FDS; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fds[i].revents &amp; POLLIN) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Data is available from fd %d.\n&quot;</span>, fds[i].fd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fds[i].revents &amp; POLLOUT) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Ready to write data to fd %d.\n&quot;</span>, fds[i].fd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><p><code>epoll</code> 是 Linux 中高性能的事件通知机制，它可以监视多个文件描述符的 I&#x2F;O 事件，并在这些文件描述符上发生事件时通知应用程序。</p>
<p>epoll把用户关心的<strong>文件描述符上的事件放在内核里的一个事件表</strong>中，从而无须像select和poll那样每次调用都要重复传入文件描述符集或事件集。但<strong>epoll需要使用一个额外的文件描述符，来唯一标识内核中的这个事件表</strong> 。这个文件描述符通过epoll_create或epoll_create1创建</p>
<h2 id="创建epoll实例"><a href="#创建epoll实例" class="headerlink" title="创建epoll实例"></a>创建epoll实例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> ＜sys/epoll.h＞</span></span><br><span class="line"><span class="type">int</span> epfd = epoll_create(<span class="type">int</span> size);</span><br><span class="line"><span class="type">int</span> epfd = epoll_create1(<span class="type">int</span> flags)	;</span><br></pre></td></tr></table></figure>

<p><code>size</code> 参数指定了 <code>epoll</code> 实例的大小，通常设置为大于零的值即可。在 Linux 2.6.8 之前的版本中，该参数没有意义，但是现在已经被忽略。</p>
<p><code>flags</code> 参数是一个位掩码，用于指定一些选项。目前支持的选项只有一个：<code>EPOLL_CLOEXEC</code>，用于在创建 <code>epoll</code> 实例时设置 <code>close-on-exec</code> 标志。如果设置了这个选项，当调用 <code>exec</code> 函数执行其他程序时，内核会自动关闭该 <code>epoll</code> 实例。<strong>简单地创建一个 <code>epoll</code> 实例，可以将 <code>flags</code> 参数设置为 0</strong>。</p>
<p><strong>当我们调用 epoll_create 函数创建一个 epoll 实例时，实际上是在内核中创建了一个数据结构来表示这个 epoll 实例</strong>。epoll 实例用于存储被监听的文件描述符及其相关信息，例如需要监听的事件类型、文件描述符的状态等。每个 epoll 实例都有一个唯一的标识符，通过这个标识符可以在用户空间中操作这个 epoll 实例。</p>
<h2 id="操作内核事件表"><a href="#操作内核事件表" class="headerlink" title="操作内核事件表"></a>操作内核事件表</h2><ul>
<li>事件表是 epoll 实例内部的数据结构，<strong>用于存储被监听的文件描述符的事件和状态。</strong>在 epoll 中，一个文件描述符可以关注多种类型的事件，主要包括可读事件（EPOLLIN）、可写事件（EPOLLOUT）、对端关闭事件（EPOLLRDHUP）等。当文件描述符上发生了关注的事件时，内核会通知用户程序进行相应的处理。 文件描述符的状态通常指的是其当前的就绪状态，即是否有事件发生或准备好进行IO操作。<strong>当文件描述符上有事件发生时，它的状态会被标记为就绪，用户程序可以通过 epoll_wait 函数等待并获取就绪的文件描述符列表</strong>，进行相应的操作。</li>
<li>在注册(<code>EPOLL_CTL_ADD</code>)文件描述符和事件时，这些信息会被存储到事件表中。事件表通常采用高效的数据结构（如<strong>红黑树</strong>）来组织，以便快速地查询、添加和删除事件。</li>
<li>当文件描述符上有事件发生时，内核会在事件表中查找对应的文件描述符，并更新其状态。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li><code>epfd</code> 是 <code>epoll</code> 实例的文件描述符。</li>
<li><code>op</code> 是操作类型，用三个宏来表示：<ul>
<li><code>EPOLL_CTL_ADD</code>：注册新的 fd 到 epfd 中；</li>
<li><code>EPOLL_CTL_MOD</code> ：修改已经注册的fd的监听事件；</li>
<li><code>EPOLL_CTL_DEL</code>：从 epfd 中删除一个 fd；</li>
</ul>
</li>
<li><code>fd</code> 是需要向内核事件表中添加&#x2F;修改&#x2F;删除的文件描述符。</li>
<li><code>event</code> 是指向 <code>epoll_event</code> 结构的指针，告诉内核要监听什么事件。定义如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> events;  <span class="comment">// 表示事件的类型</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data; <span class="comment">// 与事件相关的数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>epoll_event</code> 结构包含两个成员：</p>
<ol>
<li><code>events</code>：是一个 32 位无符号整数，表示事件的类型。可以是下列宏的组合：<ul>
<li><code>EPOLLIN</code>：表示文件描述符上有数据可读。</li>
<li><code>EPOLLOUT</code>：表示文件描述符可以进行写操作。</li>
<li><code>EPOLLRDHUP</code>：表示对端断开连接。</li>
<li><code>EPOLLERR</code>：表示发生错误。</li>
<li><code>EPOLLHUP</code>：表示发生挂起事件。</li>
<li><code>EPOLLET</code>：设置为边缘触发模式。</li>
<li><code>EPOLLONESHOT</code>：设置为单次触发模式。</li>
</ul>
</li>
<li><code>data</code>：表示事件的数据，它是一个联合体 <code>epoll_data_t</code>，可以是一个文件描述符（<code>fd</code>）或者一个指针（<code>ptr</code>）。具体定义如下：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>    *ptr;    <span class="comment">// 指针类型</span></span><br><span class="line">    <span class="type">int</span>      fd;     <span class="comment">// 文件描述符类型</span></span><br><span class="line">    <span class="type">uint32_t</span> u32;    <span class="comment">// 32 位无符号整数类型</span></span><br><span class="line">    <span class="type">uint64_t</span> u64;    <span class="comment">// 64 位无符号整数类型</span></span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>

<p><code>epoll_data</code> 联合体允许用户在事件中传递一些附加的数据。</p>
<ul>
<li><p>如果事件类型是 <code>EPOLLIN</code> 或 <code>EPOLLOUT</code>，则通常使用 <code>fd</code> 成员来表示文件描述符；</p>
</li>
<li><p>如果需要传递其他类型的数据，可以使用 <code>ptr</code> 成员来存储一个指针，或者使用 <code>u32</code> 或 <code>u64</code> 来存储一个整数值。</p>
</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>成功时，返回 0。</li>
<li>失败时，返回 -1，并设置相应的errno。</li>
</ul>
<p><strong>示例：</strong>添加一个文件描述符到内核事件表中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">event.events = EPOLLIN; <span class="comment">// 指定事件为可读事件</span></span><br><span class="line">event.data.fd = fd;     <span class="comment">// 文件描述符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;event) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;epoll_ctl: add&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="等待事件发生"><a href="#等待事件发生" class="headerlink" title="等待事件发生"></a>等待事件发生</h2><ul>
<li><p><code>epoll_wait</code> 调用会阻塞程序直到事件发生或者超时。</p>
</li>
<li><p>如果有事件发生，**<code>epoll_wait</code> 将把这些事件复制到 <code>events</code> 数组中**，并返回发生事件的数量。</p>
</li>
<li><p><code>events</code> 数组中的每个元素都是一个 <code>epoll_event</code> 结构，其中包含了发生事件的文件描述符及其事件类型。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li><code>maxevents</code> 是 <code>events</code> 数组的大小，表示最多可以存储多少个事件。</li>
<li><code>timeout</code> 是超时时间，以毫秒为单位。传递 <code>-1</code> 将一直阻塞等待事件，传递 <code>0</code> 将立即返回。</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>如果没有事件发生，且超时时间到达，则返回 0。</li>
<li>如果有事件发生，返回发生事件的数量。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line"><span class="type">int</span> nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (nfds == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理发生的事件</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; ++i) &#123;</span><br><span class="line">    <span class="comment">// 处理 events[i].data.fd 对应的文件描述符的事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p>server端：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> server_fd, new_socket, epoll_fd, nfds;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>, <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creating socket file descriptor</span></span><br><span class="line">    <span class="keyword">if</span> ((server_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Forcefully attaching socket to the port 8080</span></span><br><span class="line">    <span class="keyword">if</span> (bind(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listen(server_fd, <span class="number">5</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    epoll_fd = epoll_create1(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (epoll_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create1&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    event.data.fd = server_fd;</span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, server_fd, &amp;event) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl: server_fd&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nfds == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[i].data.fd == server_fd) &#123;</span><br><span class="line">                new_socket = accept(server_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span> (new_socket == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                event.events = EPOLLIN | EPOLLET;</span><br><span class="line">                event.data.fd = new_socket;</span><br><span class="line">                <span class="keyword">if</span> (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, new_socket, &amp;event) == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;epoll_ctl: new_socket&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> client_socket = events[i].data.fd;</span><br><span class="line">                <span class="type">int</span> valread = read(client_socket, buffer, BUFFER_SIZE);</span><br><span class="line">                <span class="keyword">if</span> (valread == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// Client disconnected</span></span><br><span class="line">                    close(client_socket);</span><br><span class="line">                    epoll_ctl(epoll_fd, EPOLL_CTL_DEL, client_socket, <span class="literal">NULL</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Client: %s\n&quot;</span>, buffer);</span><br><span class="line">                    send(client_socket, buffer, valread, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(server_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先，服务器创建一个 TCP 套接字 <code>server_fd</code>，并将其绑定到本地的 8080 端口上。然后开始监听连接请求。</li>
<li>创建了一个 epoll 实例 <code>epoll_fd</code>，并将服务器的监听套接字 <code>server_fd</code> 添加到 epoll 实例中，以便监视它上面的事件（主要是可读事件）。</li>
<li>进入一个无限循环，用于等待并处理发生在 epoll 实例中的事件。每次循环开始时，调用 <code>epoll_wait</code> 函数等待事件发生。</li>
<li>当有事件发生时，<code>epoll_wait</code> 返回并填充一个 <code>events</code> 数组，其中包含了发生的事件。</li>
<li>遍历 <code>events</code> 数组，对每一个事件进行处理。如果事件是发生在服务器监听套接字 <code>server_fd</code> 上的可读事件，说明有新的客户端连接请求到达了。</li>
<li>对新的客户端连接请求，服务器调用 <code>accept</code> 函数接受连接，创建一个新的套接字 <code>new_socket</code> 用于与客户端通信，并将新套接字添加到 epoll 实例中。</li>
<li>如果事件不是发生在监听套接字上的，则说明是已连接的客户端套接字上发生了可读事件，这表示客户端发送了数据。</li>
<li>服务器尝试从客户端套接字中读取数据，并进行处理。如果读取到的数据长度为 0，说明客户端已经关闭了连接，服务器关闭客户端套接字，并从 epoll 实例中删除该套接字。</li>
<li>循环继续，等待下一轮事件发生。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/22/%E4%BF%A1%E5%8F%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stars zhang">
      <meta itemprop="description" content="永远迎着光走">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/22/%E4%BF%A1%E5%8F%B7/" class="post-title-link" itemprop="url">信号</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-22 15:45:58" itemprop="dateCreated datePublished" datetime="2024-03-22T15:45:58+08:00">2024-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-25 15:01:11" itemprop="dateModified" datetime="2024-03-25T15:01:11+08:00">2024-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>信号是一种软件中断，它提供了异步事件的处理机制。信号作为一种进程间通信（IPC）的基本形式，而一个进程可以给另一个进程发送信号。信号本质上是一个整数，不同的信号对应不同的值，由于信号的结构简单所以天生不能携带很大的信息量，但是信号在系统中的优先级是非常高的。</p>
<p>每个信号都有一个以SIG为前缀的符号名称。信号的编号从1开始（通常是SIGHUP）线性增加。总共有大约31个<br>信号，但是大多数的程序只用到了它们中的一少部分。 </p>
<p>信号有三种状态：产生、未决、递达</p>
<p>产生：键盘输入, 函数调用, 执行shell命令, 对硬件进行非法访问都会产生信号</p>
<p>未决：信号产生, 但还没有被处理</p>
<p>递达：信号被处理后</p>
<h1 id="信号相关函数"><a href="#信号相关函数" class="headerlink" title="信号相关函数"></a>信号相关函数</h1><p>**signal()**：该函数用于设置信号处理函数，其原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span> signum, <span class="type">void</span> (*func)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p>它接受两个参数，<code>signum</code> 表示要捕获的信号类型，<code>func</code> 表示信号处理函数的指针。当收到指定的信号时，系统将调用指定的处理函数。</p>
<p>**kill()**：用于向指定的进程发送信号。其原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure>

<p><code>pid</code> 参数指定了目标进程的进程ID，<code>sig</code> 参数指定了要发送的信号类型。</p>
<p>**raise()**：用于向当前进程发送信号。其原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure>

<p><code>sig</code> 参数指定了要发送的信号类型。</p>
<p>**abort()**：给当前进程发送一个固定信号 (SIGABRT)，函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>调用 <code>abort()</code> 函数可以快速终止进程，并进行相应的清理工作</p>
<p>**sigpending()**：用于获取当前进程挂起的信号集。其原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>它将当前未决的信号放入由 <code>set</code> 参数指向的信号集中</p>
<p>**sigprocmask()**：用于检查或修改当前进程的信号屏蔽字。其原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br></pre></td></tr></table></figure>

<p>通过 <code>sigprocmask()</code> 函数可以设置当前进程的信号屏蔽字，从而阻塞或解除阻塞特定的信号。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">stars zhang</p>
  <div class="site-description" itemprop="description">永远迎着光走</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">stars zhang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
