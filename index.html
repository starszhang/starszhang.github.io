<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="永远迎着光走">
<meta property="og:type" content="website">
<meta property="og:title" content="stars">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="stars">
<meta property="og:description" content="永远迎着光走">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="stars zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>stars</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">stars</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/07/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stars zhang">
      <meta itemprop="description" content="永远迎着光走">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/07/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/" class="post-title-link" itemprop="url">浅拷贝与深拷贝</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-07 13:04:49 / 修改时间：13:59:15" itemprop="dateCreated datePublished" datetime="2024-04-07T13:04:49+08:00">2024-04-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><ul>
<li>简单的拷贝对象成员变量的值，而不拷贝对象所指向的动态分配的内存。</li>
<li>因此，新旧对象的指针成员指向相同内存地址的指针，它们将共享同一块内存，可能导致潜在的问题。</li>
<li>如果其中一个对象销毁了这个指针指向的内存，另一个对象可能会引用已经无效的内存地址。</li>
<li>当一个对象发生改变时，由于另一个对象与之共享同一块内存，另一个对象也会受到影响。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShallowCopy</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ShallowCopy</span>(<span class="type">int</span> val) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="built_in">int</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ShallowCopy</span>(<span class="type">const</span> ShallowCopy &amp;other) &#123;</span><br><span class="line">        data = other.data; <span class="comment">// 进行浅拷贝</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;shallow copy&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getData</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setData</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        *data = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ShallowCopy</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ShallowCopy <span class="title">a1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    ShallowCopy a2 = a1;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1=&quot;</span> &lt;&lt; a1.<span class="built_in">getData</span>() &lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;a2=&quot;</span> &lt;&lt; a2.<span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    a1.<span class="built_in">setData</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1=&quot;</span> &lt;&lt; a1.<span class="built_in">getData</span>() &lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;a2=&quot;</span> &lt;&lt; a2.<span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shallow copy</span><br><span class="line">a1=<span class="number">5</span> a2=<span class="number">5</span></span><br><span class="line">a1=<span class="number">10</span> a2=<span class="number">10</span></span><br></pre></td></tr></table></figure>

<h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><ul>
<li>不仅拷贝对象本身，还拷贝对象所指向的动态分配的内存，以确保拷贝后的对象和原对象指向的内存是独立的。</li>
<li>深拷贝会为新的对象分配一块新的内存，并将原对象所指向的内存的内容复制到新分配的内存中，从而使得新旧对象完全独立，互不影响。</li>
<li>即使两个对象有相同的值，它们也各自拥有一份独立的内存副本，彼此互不影响。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeepCopy</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DeepCopy</span>(<span class="type">int</span> val) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="built_in">int</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DeepCopy</span>(<span class="type">const</span> DeepCopy &amp;other) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">        *data = *(other.data); <span class="comment">// 进行深拷贝</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;deep copy&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getData</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setData</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        *data = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">DeepCopy</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">DeepCopy <span class="title">b1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">DeepCopy <span class="title">b2</span><span class="params">(b1)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b1=&quot;</span> &lt;&lt; b1.<span class="built_in">getData</span>() &lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;b2=&quot;</span> &lt;&lt; b2.<span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    b1.<span class="built_in">setData</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b1=&quot;</span> &lt;&lt; b1.<span class="built_in">getData</span>() &lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;b2=&quot;</span> &lt;&lt; b2.<span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deep copy</span><br><span class="line">b1=<span class="number">5</span> b2=<span class="number">5</span></span><br><span class="line">b1=<span class="number">10</span> b2=<span class="number">5</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/07/%E5%B7%A6%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stars zhang">
      <meta itemprop="description" content="永远迎着光走">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/07/%E5%B7%A6%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/" class="post-title-link" itemprop="url">左右值引用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-07 12:32:40 / 修改时间：13:31:44" itemprop="dateCreated datePublished" datetime="2024-04-07T12:32:40+08:00">2024-04-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="左值、右值"><a href="#左值、右值" class="headerlink" title="左值、右值"></a>左值、右值</h1><h2 id="左值："><a href="#左值：" class="headerlink" title="左值："></a>左值：</h2><ul>
<li>表达式结束后依然存在的<strong>持久性对象</strong>或者函数，可以被取地址。</li>
<li>左值是可以被标识符引用的表达式，它们代表着内存中的一个位置。例如，变量、数组元素、通过引用或指针访问的对象、具有名称的对象等都是左值。</li>
<li>左值在赋值操作符左侧出现，可以接受赋值操作。</li>
</ul>
<h2 id="右值："><a href="#右值：" class="headerlink" title="右值："></a>右值：</h2><ul>
<li>表达式结束后就消失的<strong>临时对象</strong>，通常不能被取地址。</li>
<li>右值是不具有持久性的临时对象或者表达式的结果，不能被直接引用。例如，字面常量、临时对象、未命名的临时对象、返回临时对象的函数调用等都是右值。</li>
<li>右值通常出现在赋值操作符右侧，用于提供值给赋值操作。</li>
</ul>
<h1 id="左值引用、右值引用"><a href="#左值引用、右值引用" class="headerlink" title="左值引用、右值引用"></a>左值引用、右值引用</h1><h2 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h2><ul>
<li>左值引用是通过使用 <code>&amp;</code> 符号声明的引用类型。它绑定到左值，并且可以延长左值的生命周期，使得左值可以在函数调用等情况下被修改。</li>
<li>左值引用不能绑定到右值。</li>
<li>左值引用常用于函数参数传递、函数返回值和操作符重载等场景，可以实现有效的引用语义和避免不必要的拷贝。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a; <span class="comment">// b是左值引用</span></span><br><span class="line">b = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> &amp;c = <span class="number">10</span>; <span class="comment">// error，10无法取地址，无法进行引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;d = <span class="number">10</span>; <span class="comment">// ok，因为是常引用，引用常量数字，这个常量数字会存储在内存中，可以取地址</span></span><br></pre></td></tr></table></figure>

<p>可以得出结论：对于左值引用，等号右边的值必须可以取地址，如果不能取地址，则会编译失败，或者可以使用const引用形式，但这样就只能通过引用来读取输出，不能修改数组，因为是常量引用。</p>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><ul>
<li>右值引用是通过使用 <code>&amp;&amp;</code> 符号声明的引用类型。它主要用于绑定到临时对象或者即将销毁的对象，允许移动语义的使用。</li>
<li>右值引用可以绑定到右值，但不能绑定到左值。</li>
<li>右值引用的引入使得可以实现移动语义，即将资源从一个对象“移动”到另一个对象，而不是进行昂贵的拷贝操作。这在处理临时对象时尤为有用，能够提高性能。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;&#125; <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; other) &#123;&#125; <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp; other) &#123;&#125; <span class="comment">// 移动构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">createA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">A</span>(); <span class="comment">// 返回一个临时对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a1 = <span class="built_in">createA</span>(); <span class="comment">// 调用移动构造函数，避免了拷贝</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>std::move函数：把一个左值强制转换成一个右值 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> &amp;&amp;b = a; <span class="comment">// error, a是左值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;c = std::<span class="built_in">move</span>(a); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/05/%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stars zhang">
      <meta itemprop="description" content="永远迎着光走">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/05/%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">指针和引用的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-05 18:15:10 / 修改时间：18:49:25" itemprop="dateCreated datePublished" datetime="2024-04-05T18:15:10+08:00">2024-04-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>定义</li>
</ol>
<p>（1）指针是一个变量，其值为另一个变量的地址，指向内存的一个存储单元。是一个对象实体</p>
<p>（2）而引用的本质是给变量起别名，允许通过这个别名去直接操纵和修改对象本身的属性。引用跟原来的变量实质上是同一个东西。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//指针</span></span><br><span class="line"><span class="type">int</span>* p = &amp;a;</span><br><span class="line"><span class="comment">//引用</span></span><br><span class="line"><span class="type">int</span>&amp; b = a;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>空指针与无效引用</li>
</ol>
<p>（1）指针可以为空，表示它不指向任何有效的内存地址。在指针没有被初始化时，它的值通常是未定义的，为了避免错误，可以将其初始化为 <code>nullptr</code> 或 <code>NULL</code>。</p>
<p>（2）引用不能为空，它必须在声明时被初始化，并且始终指向某个对象。试图将引用声明为 null 或者空值会导致编译错误。</p>
<ol start="3">
<li>初始化</li>
</ol>
<p>（1）指针需要进行初始化，可以使用取地址符号 <code>&amp;</code> 来获取一个变量的地址，也可以将另一个指针赋值给它。</p>
<p>（2）引用在声明时必须初始化，而且一旦初始化后，不能被重新绑定到其他变量。</p>
<ol start="4">
<li>运算符</li>
</ol>
<p>（1）指针可以通过解引用 <code>*</code> 运算符来访问所指向的对象，也可以使用箭头 <code>-&gt;</code> 运算符来访问成员，例如：<code>p-&gt;member</code>。</p>
<p>（2）引用则不需要解引用操作符，因为它们在使用时就是被解引用的。例如：<code>b.member</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/27/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stars zhang">
      <meta itemprop="description" content="永远迎着光走">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/27/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/" class="post-title-link" itemprop="url">线程同步</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-27 13:12:33" itemprop="dateCreated datePublished" datetime="2024-03-27T13:12:33+08:00">2024-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-30 13:22:45" itemprop="dateModified" datetime="2024-03-30T13:22:45+08:00">2024-03-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>进程有自己的独立地址空间，因此<strong>进程之间重点关注通信</strong>。而对于线程来说，除了线程栈外其他数据都是共享的，如果同时读写数据可能造成数据不一致甚至程序崩溃的后果，因此<strong>线程之间重点关注同步</strong>。</p>
<p>线程同步是指在多线程编程中控制多个线程之间的执行顺序或共享资源访问的过程。在多线程环境中，由于线程的并发执行，可能会导致数据竞争、资源冲突等问题。</p>
<h1 id="1-竞争条件"><a href="#1-竞争条件" class="headerlink" title="1. 竞争条件"></a>1. 竞争条件</h1><p>在多线程并发场景下指令执行的先后顺序由内核决定，同一个线程内部指令按照先后顺序执行，但不同线程之间的指令执行先后顺序是不一定的。如果执行结果依赖于不同线程执行的先后顺序，那么就会形成<strong>“竞争条件”</strong>，产生非预期的计算结果，导致程序崩溃等问题。</p>
<p>最常见的解决竞争条件的方式是<strong>原子操作</strong>，其次便是<strong>线程同步</strong>。</p>
<p>原子操作是指不可被中断的操作，在执行过程中不会被其他线程或进程干扰，要么全部执行成功，要么全部不执行，不会出现部分执行的情况。原子操作通常是基本的、不可分割的操作单元。</p>
<p>原子操作通常由硬件或者操作系统提供支持，C++11引入了std::atomic模板类来支持原子操作。</p>
<h1 id="2-线程同步"><a href="#2-线程同步" class="headerlink" title="2. 线程同步"></a>2. 线程同步</h1><p>常见的线程同步的方式有四种：互斥锁、读写锁、条件变量和信号量</p>
<h2 id="2-1-互斥锁"><a href="#2-1-互斥锁" class="headerlink" title="2.1 互斥锁"></a>2.1 互斥锁</h2><p>互斥锁（又名互斥量）强调的是资源之间的访问互斥：每个线程在对共享资源操作前都会尝试先加锁，加锁成功才能操作，操作结束之后解锁。</p>
<p>某个线程对互斥量加锁后，其他线程必须等待该线程释放锁才能继续访问共享资源。如果释放互斥锁时有多个线程阻塞，所有在该互斥锁上的阻塞线程都会变成可运行状态。第一个变成运行状态的线程可以对互斥量加锁，其余线程将会看到互斥量依然被锁住，只能回去再次等待它重新变为可用。</p>
<p>mutex是睡眠等待（sleep waiting）类型的锁，<strong>当线程抢互斥锁失败的时候，线程会陷入休眠</strong>。优点就是节省CPU资源，缺点就是休眠唤醒会消耗一点时间。</p>
<p>互斥锁的接口通常包括 <code>mutex_init()</code>、<code>mutex_lock()</code>、<code>mutex_unlock()</code> 和 <code>mutex_destroy()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化互斥锁</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁互斥锁</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2-2-读写锁"><a href="#2-2-读写锁" class="headerlink" title="2.2 读写锁"></a>2.2 读写锁</h2><p>读写锁和互斥量类似，是另一种实现线程同步的方式，但是它将操作分为读、写两种方式，可以多个线程同时占用读模式，但只允许一个线程写入。</p>
<ul>
<li>写独占：写锁占用时，其他线程加读锁或者写锁时都会阻塞（并非失败）</li>
<li>读共享：读锁占用时，其他线程加写锁时会阻塞，加读锁会成功</li>
</ul>
<p>读写锁有两种策略：</p>
<ul>
<li>强读同步：读锁优先，只要写锁没有占用那么就可以加读锁</li>
<li>强写同步：写锁优先，只能等到所有正在等待或者执行的写锁执行完成后才能加读锁</li>
</ul>
<p>大部分读写锁的实现都采用的是“强写同步”策略，对尝试加锁的操作进行排队，如果前面已经有尝试加写被锁阻塞住的话，后续加读锁也都会被阻塞住（尽管当前时刻是读锁占用的状态）。这样做的目的主要是为了避免“写饥饿”，在“多读少写”的情况下防止数据修改延迟过高。</p>
<p>读写锁的接口通常包括 <code>rwlock_init()</code>、<code>rwlock_rdlock()</code>、<code>rwlock_wrlock()</code>、<code>rwlock_unlock()</code> 和 <code>rwlock_destroy()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化读写锁</span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line">pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取加锁</span></span><br><span class="line">pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入加锁</span></span><br><span class="line">pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁读写锁</span></span><br><span class="line">pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-3-条件变量"><a href="#2-3-条件变量" class="headerlink" title="2.3 条件变量"></a>2.3 条件变量</h2><p>严格意义上来说，条件变量的主要作用不是处理线程同步, 而是进行线程的阻塞。如果在多线程程序中只使用条件变量无法实现线程的同步, 必须要配合互斥锁来使用。</p>
<p>线程可以等待某个条件变量的发生，如果条件不满足，则线程会阻塞等待，并在条件满足时被唤醒。</p>
<p>条件变量的接口通常包括 <code>cond_init()</code>、<code>cond_wait()</code>、<code>cond_signal()</code> 和 <code>cond_broadcast()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化条件变量和关联的互斥锁</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待条件满足</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送信号通知条件满足</span></span><br><span class="line">pthread_cond_signal(&amp;cond);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广播通知条件满足</span></span><br><span class="line">pthread_cond_broadcast(&amp;cond);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-4-信号量"><a href="#2-4-信号量" class="headerlink" title="2.4 信号量"></a>2.4 信号量</h2><p>信号量是一种更为通用的同步原语，用来控制多个线程对共享资源的访问。</p>
<p>信号量本质上是一个非负的整数计数器，表示可用资源的数量。当资源被占用时，计数器减少；当资源释放时，计数器增加。</p>
<p>信号量提供了两种操作：P操作（等待信号量）和V操作（释放信号量），用于控制资源的访问和释放，也被称为PV原子操作：</p>
<ul>
<li>P操作：即信号量sem减一，若sem小于等于0则P操作被阻塞，直到sem变量大于0为止</li>
<li>V操作：即信号量sem加一</li>
</ul>
<p>信号量的接口通常包括 <code>sem_init()</code>、<code>sem_wait()</code>、<code>sem_post()</code> 和 <code>sem_destroy()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="type">sem_t</span> semaphore;</span><br><span class="line">sem_init(&amp;semaphore, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 初始值为1，表示有一个资源可用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待信号量</span></span><br><span class="line">sem_wait(&amp;semaphore);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送信号量</span></span><br><span class="line">sem_post(&amp;semaphore);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁信号量</span></span><br><span class="line">sem_destroy(&amp;semaphore);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="3-C-示例"><a href="#3-C-示例" class="headerlink" title="3. C++示例"></a>3. C++示例</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">// 用于 sleep 函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享资源</span></span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁</span></span><br><span class="line">mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读写锁</span></span><br><span class="line">shared_mutex rw_mtx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件变量</span></span><br><span class="line">condition_variable cond_var;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量</span></span><br><span class="line"><span class="type">sem_t</span> semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mutex_example</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is accessing shared resource with mutex. Shared data: &quot;</span> &lt;&lt; shared_data &lt;&lt; endl;</span><br><span class="line">    shared_data++;</span><br><span class="line">    mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读写锁示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rw_lock_example</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 读操作</span></span><br><span class="line">        <span class="function">shared_lock&lt;shared_mutex&gt; <span class="title">lock</span><span class="params">(rw_mtx)</span></span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is reading shared resource with read-write lock. Shared data: &quot;</span> &lt;&lt; shared_data &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 写操作</span></span><br><span class="line">        unique_lock&lt;shared_mutex&gt; <span class="built_in">lock</span>(rw_mtx);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is writing shared resource with read-write lock. Shared data: &quot;</span> &lt;&lt; shared_data &lt;&lt; endl;</span><br><span class="line">        shared_data++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件变量示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cond_var_example</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    cond_var.<span class="built_in">wait</span>(lock, []&#123; <span class="keyword">return</span> ready; &#125;);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is accessing shared resource with condition variable. Shared data: &quot;</span> &lt;&lt; shared_data &lt;&lt; endl;</span><br><span class="line">    shared_data++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">semaphore_example</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;semaphore);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is accessing shared resource with semaphore. Shared data: &quot;</span> &lt;&lt; shared_data &lt;&lt; endl;</span><br><span class="line">    shared_data++;</span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;semaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;semaphore, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(mutex_example, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(mutex_example, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(rw_lock_example, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t4</span><span class="params">(rw_lock_example, <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t5</span><span class="params">(cond_var_example, <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t6</span><span class="params">(cond_var_example, <span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t7</span><span class="params">(semaphore_example, <span class="number">7</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t8</span><span class="params">(semaphore_example, <span class="number">8</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知条件变量</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cond_var.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    t4.<span class="built_in">join</span>();</span><br><span class="line">    t5.<span class="built_in">join</span>();</span><br><span class="line">    t6.<span class="built_in">join</span>();</span><br><span class="line">    t7.<span class="built_in">join</span>();</span><br><span class="line">    t8.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;semaphore);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4. 死锁"></a>4. 死锁</h1><p>死锁（Deadlock）是指两个或多个进程(线程)在互相等待对方持有的资源而无法继续执行的情况。在死锁状态下，每个进程都在等待某个资源被释放，而该资源被其他进程所持有，导致所有进程都无法继续执行。</p>
<p>死锁发生的<strong>主要原因</strong>通常是由于多个进程同时持有某些资源，并且每个进程都在等待其他进程释放它所需要的资源。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stars zhang">
      <meta itemprop="description" content="永远迎着光走">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">C++并发与多线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-26 19:37:30" itemprop="dateCreated datePublished" datetime="2024-03-26T19:37:30+08:00">2024-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-05 10:15:47" itemprop="dateModified" datetime="2024-04-05T10:15:47+08:00">2024-04-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一个程序只有一个进程，但可以拥有至少一个线程（主线程），这些线程共同拥有进程的地址空间。</p>
<p>C++11通过std::thread进行多线程编程</p>
<h1 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1. 构造函数"></a>1. 构造函数</h1><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">类别</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">thread() noexcept</td>
<td align="center">默认构造函数</td>
<td align="center">创建一个线程，但什么也不做</td>
</tr>
<tr>
<td align="center">template&lt; class Function, class… Args &gt;<br>explicit thread( Function&amp;&amp; f, Args&amp;&amp;… args )</td>
<td align="center">初始化构造函数</td>
<td align="center">创建一个线程，以<code>args</code>为参数执行<code>fn</code>函数</td>
</tr>
<tr>
<td align="center">thread( thread&amp;&amp; other ) noexcept</td>
<td align="center">移动构造函数</td>
<td align="center">将 other 的线程所有权转移给新的thread 对象</td>
</tr>
<tr>
<td align="center">thread( const thread&amp; ) &#x3D; delete</td>
<td align="center">复制构造函数</td>
<td align="center">使用&#x3D;delete显示删除拷贝构造, 不允许线程对象之间的拷贝</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/25/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stars zhang">
      <meta itemprop="description" content="永远迎着光走">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/25/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" class="post-title-link" itemprop="url">IO多路复用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-03-25 10:00:09 / 修改时间：10:45:14" itemprop="dateCreated datePublished" datetime="2024-03-25T10:00:09+08:00">2024-03-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>应用通常需要在多个文件描述符上阻塞：在键盘输入（stdin）、进程间通信以及很多文件之间协调I&#x2F;O 。在传统的IO模型中，每个IO操作都需要创建一个新的线程或进程来处理。如果不使用线程，而是独立处理每个文件描述，单个进程无法同时在多个文件描述符上阻塞。 </p>
<p>I&#x2F;O多路复用支持一个线程同时监测多个文件描述符并且这个过程是阻塞的，当有IO操作可以进行时才唤醒线程进行处理，避免了频繁的线程创建和切换，提高了系统的效率。 </p>
<p>多线程&#x2F;多进程并发和IO多路转接的并发处理流程进行对比（服务器端）：</p>
<ul>
<li><p>多线程&#x2F;多进程并发</p>
<ul>
<li>主线程&#x2F;父进程：调用 accept()监测客户端连接请求，如果没有新的客户端的连接请求，当前线程&#x2F;进程会阻塞；如果有新的客户端连接请求解除阻塞，建立连接</li>
<li>子线程&#x2F;子进程：和建立连接的客户端通信。<ul>
<li>调用 read() &#x2F; recv() 接收客户端发送的通信数据，如果没有通信数据，当前线程&#x2F;进程会阻塞，数据到达之后阻塞自动解除</li>
<li>调用 write() &#x2F; send() 给客户端发送数据，如果写缓冲区已满，当前线程&#x2F;进程会阻塞，否则将待发送数据写入写缓冲区中</li>
</ul>
</li>
</ul>
</li>
<li><p>IO多路复用并发</p>
<ul>
<li><p>使用IO多路复用函数委托内核检测服务器端所有的文件描述符（通信和监听两类），检测过程会导致进程&#x2F;线程的阻塞，如果检测到已就绪的文件描述符阻塞解除，并将这些已就绪的文件描述符传出</p>
</li>
<li><p>根据类型对传出的所有已就绪文件描述符进行判断，并做出不同的处理</p>
<ul>
<li><p>监听的文件描述符：和客户端建立连接，此时调用accept()不会导致程序阻塞，因为监听的文件描述符是已就绪的（有新请求）</p>
</li>
<li><p>通信的文件描述符：调用通信函数和已建立连接的客户端通信，调用 read() &#x2F; recv() 不会阻塞程序，因为通信的文件描述符是就绪的，读缓冲区内已有数据；调用 write() &#x2F; send() 不会阻塞程序，因为通信的文件描述符是就绪的，写缓冲区不满，可以往里面写数据</p>
</li>
</ul>
</li>
<li><p>对这些文件描述符继续进行下一轮的检测</p>
</li>
</ul>
</li>
</ul>
<p>Linux提供了三种I&#x2F;O多路复用方案：select、poll和epoll </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/22/%E4%BF%A1%E5%8F%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stars zhang">
      <meta itemprop="description" content="永远迎着光走">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/22/%E4%BF%A1%E5%8F%B7/" class="post-title-link" itemprop="url">信号</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-22 15:45:58" itemprop="dateCreated datePublished" datetime="2024-03-22T15:45:58+08:00">2024-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-25 15:01:11" itemprop="dateModified" datetime="2024-03-25T15:01:11+08:00">2024-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>信号是一种软件中断，它提供了异步事件的处理机制。信号作为一种进程间通信（IPC）的基本形式，而一个进程可以给另一个进程发送信号。信号本质上是一个整数，不同的信号对应不同的值，由于信号的结构简单所以天生不能携带很大的信息量，但是信号在系统中的优先级是非常高的。</p>
<p>每个信号都有一个以SIG为前缀的符号名称。信号的编号从1开始（通常是SIGHUP）线性增加。总共有大约31个<br>信号，但是大多数的程序只用到了它们中的一少部分。 </p>
<p>信号有三种状态：产生、未决、递达</p>
<p>产生：键盘输入, 函数调用, 执行shell命令, 对硬件进行非法访问都会产生信号</p>
<p>未决：信号产生, 但还没有被处理</p>
<p>递达：信号被处理后</p>
<h1 id="信号相关函数"><a href="#信号相关函数" class="headerlink" title="信号相关函数"></a>信号相关函数</h1><p>**signal()**：该函数用于设置信号处理函数，其原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span> signum, <span class="type">void</span> (*func)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p>它接受两个参数，<code>signum</code> 表示要捕获的信号类型，<code>func</code> 表示信号处理函数的指针。当收到指定的信号时，系统将调用指定的处理函数。</p>
<p>**kill()**：用于向指定的进程发送信号。其原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure>

<p><code>pid</code> 参数指定了目标进程的进程ID，<code>sig</code> 参数指定了要发送的信号类型。</p>
<p>**raise()**：用于向当前进程发送信号。其原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure>

<p><code>sig</code> 参数指定了要发送的信号类型。</p>
<p>**abort()**：给当前进程发送一个固定信号 (SIGABRT)，函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>调用 <code>abort()</code> 函数可以快速终止进程，并进行相应的清理工作</p>
<p>**sigpending()**：用于获取当前进程挂起的信号集。其原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>它将当前未决的信号放入由 <code>set</code> 参数指向的信号集中</p>
<p>**sigprocmask()**：用于检查或修改当前进程的信号屏蔽字。其原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br></pre></td></tr></table></figure>

<p>通过 <code>sigprocmask()</code> 函数可以设置当前进程的信号屏蔽字，从而阻塞或解除阻塞特定的信号。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/21/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stars zhang">
      <meta itemprop="description" content="永远迎着光走">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/21/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">进程管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-21 18:27:10" itemprop="dateCreated datePublished" datetime="2024-03-21T18:27:10+08:00">2024-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-30 13:29:47" itemprop="dateModified" datetime="2024-03-30T13:29:47+08:00">2024-03-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-进程概述"><a href="#1-进程概述" class="headerlink" title="1. 进程概述"></a>1. 进程概述</h1><p>程序：就是磁盘上的可执行文件文件, 并且只占用磁盘上的空间，是一个静态的概念</p>
<p>进程：是处于执行状态的程序以及相关资源的总称。每个运行的进程的都对应一个属于自己的虚拟地址空间，这是一个动态的概念</p>
<h2 id="PCB进程控制块"><a href="#PCB进程控制块" class="headerlink" title="PCB进程控制块"></a>PCB进程控制块</h2><p>内核把进程的列表存放在叫做任务队列的双向循环链表中，链表的每一个节点都是类型为task_struct的结构体，即<strong>进程描述符</strong>。进程描述符中包含了内核管理一个进程所需的所有信息，如：</p>
<ul>
<li><p>进程id：每一个进程都一个唯一的进程ID，类型为 pid_t, 本质是一个int类型</p>
</li>
<li><p>文件描述符表：每个被分配的文件描述符都对应一个已经打开的磁盘文件</p>
</li>
<li><p>进程的状态：初始态、就绪态、运行态、挂起态、终止态</p>
</li>
<li><p>进程工作目录</p>
</li>
<li><p>umask掩码：创建新文件时，通过这个掩码屏蔽某些用于对文件的操作权限</p>
</li>
<li><p>用户id和组id：当前进程所属用户及用户组</p>
</li>
</ul>
<h1 id="2-进程创建"><a href="#2-进程创建" class="headerlink" title="2. 进程创建"></a>2. 进程创建</h1><p>在Linux系统中，现有进程调用fork()就会创建一个子进程，fork()调用一次会返回两次，一次是向父进程返回子进程的进程ID，一次向子进程返回0。函数原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>在调用 <code>fork()</code> 后，操作系统会复制父进程的所有资源（包括内存、文件描述符、堆栈等），并将它们分配给新创建的子进程，子进程接着从 <code>fork()</code> 调用之后的位置继续执行。</p>
<p>通过getpid()能查看当前进程ID，调用getppid查看父进程的ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure>

<p>Linux的fork()使用写时拷贝技术(copy on write–COW)实现，是一种推迟甚至免除复制数据的技术，父子进程共享同一段内存，只有在需要写入的时候才会执行复制数据的操作。通过这种方式能够减少内存复制的开销，特别是在多个进程之间共享大块内存时，可以显著减少内存占用和提高性能。</p>
<h1 id="3-exec函数"><a href="#3-exec函数" class="headerlink" title="3. exec函数"></a>3. exec函数</h1><p>一般进程在创建完毕后会调用exec()读取一个可执行文件并将其载入地址空间开始运行，此时该进程的代码段、数据段、堆栈等完全替换为新程序，进程ID保持不变。</p>
<p>exec函数共有7中不同的变体，分别是<code>execl</code>、<code>execv</code>、<code>execle</code>、<code>execve</code>、<code>execlp</code>、<code>execvp</code>、<code>fexecve</code>。它们的主要区别在于传递参数的方式以及如何指定环境变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ... <span class="comment">/* (char  *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ... <span class="comment">/* (char  *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">           					<span class="comment">/*, (char *) NULL, char * const envp[] */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure>

<h1 id="4-进程终止"><a href="#4-进程终止" class="headerlink" title="4. 进程终止"></a>4. 进程终止</h1><p>进程的常见终止方式：</p>
<ul>
<li>main函数中执行return语句</li>
<li>调用exit()或_exit()</li>
</ul>
<p>函数的参数相当于退出码, 如果参数值为 0 程序退出之后的状态码就是0, 如果是100退出的状态码就是100。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _<span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span></span><br></pre></td></tr></table></figure>

<h1 id="5-进程控制"><a href="#5-进程控制" class="headerlink" title="5. 进程控制"></a>5. 进程控制</h1><h2 id="5-1-孤儿进程"><a href="#5-1-孤儿进程" class="headerlink" title="5.1 孤儿进程"></a>5.1 孤儿进程</h2><p>在一个启动的进程中创建子进程，这时候父子进程同时运行，当父进程结束或者被终止时，而子进程还在继续执行，这种情况下子进程被称为孤儿进程。</p>
<p>这种情况下，操作系统会将该子进程的父进程设置为init进程（在Linux系统中通常为进程ID为1的init进程）。init进程会接管孤儿进程并负责它的管理。</p>
<p>那么系统为什么要接管这个孤儿进程呢？在子进程退出的时候, 进程中的用户区可以自己释放, 但是进程内核区的PCB资源自己无法释放，必须要由父进程来释放子进程的PCB资源。</p>
<h2 id="5-2-僵尸进程"><a href="#5-2-僵尸进程" class="headerlink" title="5.2 僵尸进程"></a>5.2 僵尸进程</h2><p>僵尸进程指已经终止执行的子进程，但是其父进程还未对其进行善后处理（即收回其占用的系统资源和进程表中的条目），僵尸进程仍然在进程表中存在，但是它已经停止了执行，并且释放了大部分系统资源，仅保留一些基本信息，例如进程ID和终止状态。</p>
<h2 id="5-3-进程回收-wait-waitpid"><a href="#5-3-进程回收-wait-waitpid" class="headerlink" title="5.3 进程回收(wait&#x2F;waitpid)"></a>5.3 进程回收(wait&#x2F;waitpid)</h2><p>要解决僵尸进程问题，父进程通常需要调用 <code>wait()</code> 或 <code>waitpid()</code> 等系统调用来等待子进程的终止，并获取其终止状态，然后将其彻底清理掉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure>

<p>调用wait()&#x2F;waitpid()的进程可能会发生：</p>
<ul>
<li>如果其所有子进程仍在运行，则阻塞</li>
<li>如果一个子进程已终止，正等待父进程获取终止状态，则取得该子进程的终止状态立即返回</li>
<li>如果没有任何子进程，则立即出错返回</li>
</ul>
<p>waitpid() 可以看做是 wait() 的升级版，通过该函数可以控制回收子进程资源的方式是阻塞还是非阻塞，另外还可以通过该函数进行精准打击，可以精确指定回收某个或者某一类或者是全部子进程资源。</p>
<ul>
<li><p>pid: </p>
<ul>
<li>-1时，同wait()一样</li>
<li>0时，回收当前进程的所有子进程</li>
<li>大于0时，指定回收ID为pid的子进程</li>
</ul>
</li>
<li><p>status: NULL, 和wait的参数是一样的</p>
</li>
<li><p>options: 控制函数是阻塞还是非阻塞，0表示阻塞， <code>WNOHANG</code>表示非阻塞</p>
</li>
</ul>
<h1 id="6-进程间通信"><a href="#6-进程间通信" class="headerlink" title="6. 进程间通信"></a>6. 进程间通信</h1><p>Linux支持的进程间通信机制包括<strong>管道</strong>、<strong>命名管道</strong>、<strong>信号量</strong>、<strong>消息队列</strong>、<strong>共享内存</strong>、<strong>套接字</strong></p>
<h2 id="6-1-管道"><a href="#6-1-管道" class="headerlink" title="6.1 管道"></a>6.1 管道</h2><p>管道是一种半双工的通信方式，分为<strong>匿名管道pipe</strong>和<strong>命名管道FIFO</strong>两种。匿名管道只存在于内存中，且只能用于具有<strong>亲缘关系的进程</strong>，通常用于父子进程之间。命名管道（FIFO）则是一种特殊的文件，可以用于不同进程之间的通信。</p>
<p><code>pipe()</code> 系统调用创建一个管道，返回两个文件描述符，一个用于读取数据，另一个用于写入数据。通常与 <code>fork()</code> 系统调用一起使用，创建一个父子进程，然后使用 <code>dup()</code> 复制文件描述符以便父子进程可以在管道中进行通信，最后使用 <code>close()</code> 关闭不需要的文件描述符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建一个匿名的管道, 得到两个可用的文件描述符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li>pipefd[0]: 对应管道读端的文件描述符，通过它可以将数据从管道中读出</li>
<li>pipefd[1]: 对应管道写端的文件描述符，通过它可以将数据写入到管道中</li>
</ul>
<p>返回值：成功返回0，失败返回-1</p>
<p>使用 <code>mkfifo()</code> 创建一个命名管道，然后可以使用 <code>open()</code> 打开该命名管道，之后使用 <code>read()</code> 和 <code>write()</code> 进行数据的读写操作，最后使用 <code>close()</code> 关闭文件描述符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="comment">// int open(const char *pathname, int flags, mode_t mode);</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<p>参数:<br>pathname: 要创建的有名管道的名字<br>mode: 文件的操作权限, 和open()的第三个参数一个作用，最终权限: (mode &amp; ~umask)<br>返回值：创建成功返回 0，失败返回 -1</p>
<h2 id="6-2-消息队列"><a href="#6-2-消息队列" class="headerlink" title="6.2 消息队列"></a>6.2 消息队列</h2><p>消息队列是一种通过消息传递进行通信的机制，允许一个进程向队列发送消息，其他进程从队列中接收消息。</p>
<p>使用 <code>msgget()</code> 创建或打开一个消息队列，然后使用 <code>msgsnd()</code> 发送消息到队列中，使用 <code>msgrcv()</code> 从队列中接收消息，使用 <code>msgctl()</code> 控制消息队列的属性。</p>
<h2 id="6-3-信号量"><a href="#6-3-信号量" class="headerlink" title="6.3 信号量"></a>6.3 信号量</h2><p>信号量是一种用于进程间同步和互斥的机制，通常用于解决共享资源的访问问题</p>
<p>使用 <code>semget()</code> 创建或打开一个信号量集，然后使用 <code>semop()</code> 对信号量进行操作，包括对信号量的增减、等待等操作，最后使用 <code>semctl()</code> 控制信号量集的属性。</p>
<h2 id="6-4-共享内存"><a href="#6-4-共享内存" class="headerlink" title="6.4 共享内存"></a>6.4 共享内存</h2><p>共享内存是一种高效的进程间通信方式，允许多个进程直接访问同一块内存区域，从而实现数据共享。<strong>在所有进程间通信的方式中共享内存的效率是最高的。</strong></p>
<p>使用 <code>shmget()</code> 创建或打开一个共享内存段，然后使用 <code>shmat()</code> 将共享内存连接到当前进程的地址空间，之后可以直接在内存中进行读写操作，最后使用 <code>shmdt()</code> 断开共享内存的连接，使用 <code>shmctl()</code> 控制共享内存的属性。</p>
<h2 id="6-5-套接字"><a href="#6-5-套接字" class="headerlink" title="6.5 套接字"></a>6.5 套接字</h2><p>套接字是一种在网络编程中常用的进程间通信方式，它允许不同主机上的进程进行通信</p>
<p>使用 <code>socket()</code> 创建一个套接字，然后使用 <code>bind()</code> 绑定套接字到特定的地址和端口，使用 <code>listen()</code> 监听连接请求，使用 <code>accept()</code> 接受连接请求并创建新的套接字，然后使用 <code>connect()</code> 连接到远程主机的套接字，之后可以使用 <code>send()</code> 和 <code>recv()</code> 进行数据的发送和接收，最后使用 <code>close()</code> 关闭套接字。</p>
<h1 id="7-守护进程"><a href="#7-守护进程" class="headerlink" title="7. 守护进程"></a>7. 守护进程</h1><p>守护进程（Daemon Process）是在后台运行的一种特殊类型的进程，它通常在系统启动时启动，并在整个系统运行期间持续执行，独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。</p>
<h2 id="如何创建守护进程"><a href="#如何创建守护进程" class="headerlink" title="如何创建守护进程"></a>如何创建守护进程</h2><ol>
<li>调用fork()，创建新的子进程</li>
<li>在父进程中调用exit()。这会确保父进程的父进程（即守护进程的祖父进程）在其子进程结束时会退出，保证了守护进程的父进程不再继续运行，而且守护进程不是首进程。最后一点是成功完成下一步骤的前提 </li>
<li>通过调用 <code>setsid()</code> 函数创建一个新的会话，使守护进程成为会话的领头进程，并且摆脱终端的控制。</li>
<li>在子进程中，通过调用 <code>umask()</code> 函数来<strong>修改文件掩码</strong>，以确保守护进程创建的文件具有合适的权限。</li>
<li>为了确保守护进程不会影响其他进程的工作目录，一般会将工作目录<strong>切换</strong>到根<strong>目录</strong></li>
<li><strong>关闭</strong>守护进程继承的<strong>文件描述符</strong>，以避免其影响其他进程或继承终端。</li>
<li>为了确保守护进程能够正常退出或重新加载配置等，需要注册一些信号处理函数，比如 <code>SIGTERM</code> 和 <code>SIGHUP</code> 信号。</li>
<li>在守护进程初始化完成后，执行它的核心功能，比如提供网络服务、定时任务等。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建失败</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程退出</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在子进程中执行以下操作</span></span><br><span class="line">    <span class="comment">// 创建一个新会话</span></span><br><span class="line">    <span class="keyword">if</span> (setsid() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改文件掩码</span></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变工作目录</span></span><br><span class="line">    chdir(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    close(STDIN_FILENO);</span><br><span class="line">    close(STDOUT_FILENO);</span><br><span class="line">    close(STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册信号处理函数</span></span><br><span class="line">    signal(SIGTERM, signal_handler);</span><br><span class="line">    signal(SIGHUP, signal_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行守护进程的核心功能</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Do something</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/19/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stars zhang">
      <meta itemprop="description" content="永远迎着光走">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/19/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">拷贝构造函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-19 19:06:45" itemprop="dateCreated datePublished" datetime="2024-03-19T19:06:45+08:00">2024-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-24 16:17:00" itemprop="dateModified" datetime="2024-03-24T16:17:00+08:00">2024-03-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1. 构造函数"></a>1. 构造函数</h1><p>构造函数按类型分为<strong>普通构造函数</strong>和<strong>拷贝构造函数</strong>。如果一个类的构造函数的第一个参数是该类型的引用，则是拷贝构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="comment">//无参构造函数</span></span><br><span class="line">	<span class="built_in">person</span>()&#123;</span><br><span class="line">        score = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有参构造函数</span></span><br><span class="line">    <span class="built_in">person</span>(<span class="type">int</span> score)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;score = score;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">person</span>(<span class="type">const</span> person&amp; p)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = p.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参构造函数</span></span><br><span class="line"><span class="function">person <span class="title">p1</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="comment">//调用拷贝构造函数</span></span><br><span class="line"><span class="function">person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">person p3 = p1;</span><br></pre></td></tr></table></figure>

<h1 id="2-构造函数调用规则"><a href="#2-构造函数调用规则" class="headerlink" title="2. 构造函数调用规则"></a>2. 构造函数调用规则</h1><p>默认情况下，C++编译器至少为一个类添加3个函数</p>
<p>​	1．默认构造函数(<strong>无参</strong>，函数体为<strong>空</strong>)</p>
<p>​	2．默认析构函数(无参，函数体为空)</p>
<p>​	3．默认拷贝构造函数(<strong>对属性进行值拷贝</strong>)</p>
<p>但当用户定义了构造函数，调用规则如下：</p>
<ul>
<li>如果用户定义了有参构造函数，c++则不再提供默认无参构造，但是会提供默认拷贝构造</li>
<li>如果用户定义了拷贝构造函数，c++则不再提供默认构造函数，需要用户定义普通构造函数</li>
</ul>
<h1 id="3-深拷贝与浅拷贝"><a href="#3-深拷贝与浅拷贝" class="headerlink" title="3. 深拷贝与浅拷贝"></a>3. 深拷贝与浅拷贝</h1><ul>
<li>浅拷贝：在拷贝对象时只拷贝对象的指针，而没有拷贝指针所指向的动态分配的内存内容，<strong>新旧对象都指向同一块内存</strong>。造成的结果就是<strong>当其中一个对象的析构函数被调用时，会释放该内存，从而导致另一个对象访问无效内存</strong>，从而引发问题。</li>
<li>深拷贝：在拷贝对象时，<strong>会复制对象所指向的动态分配的内存，而不只是复制指针本身</strong>。这样做可以确保每个对象都有其自己的一份独立的内存副本。</li>
<li>总结：浅拷贝只是简单地复制指针，导致多个对象共享同一块内存，容易出现悬空指针或者资源释放问题。深拷贝会为新对象分配内存，并将原对象的数据复制到新内存中，确保每个对象都有独立的内存空间，从而避免了悬空指针或资源释放问题。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/18/perror%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stars zhang">
      <meta itemprop="description" content="永远迎着光走">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stars">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/18/perror%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">perrpr函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-03-18 20:12:54 / 修改时间：21:12:12" itemprop="dateCreated datePublished" datetime="2024-03-18T20:12:54+08:00">2024-03-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>当linux系统函数出错时，通常会返回一个负值，并将整型变量errno设置为具有特定信息的值。头文件error.h中定义了errno以及它的各个常量值。</p>
<p>perror函数用于将最近的错误码（由全局变量 <code>errno</code> 表示）转换为对应的错误消息，并输出到标准错误流（<code>stderr</code>）。它的原型如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数首先输出由msg指向的字符串，然后是一个冒号，一个空格，接着是对应于errno值的出错消息，最后是换行符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;nonexistent_file.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>open函数尝试打开名为”nonexistent_file.txt”的不存在文件，因此会导致一个错误。此时会输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open: No such file or directory</span><br></pre></td></tr></table></figure>

<p>其中 “No such file or directory” 是由 <code>errno</code> 变量指定的错误消息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">stars zhang</p>
  <div class="site-description" itemprop="description">永远迎着光走</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">stars zhang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
